---
title: Python技巧
categories: '04_学习笔记'
tags:
  - python
  - 速查
date: 2018-06-22 00:09:52
---

{% asset_path 20180622-Python技巧 %}

**概述：** python的一些Tips，浓缩都是精华啊...

 <!-- more -->

# PythonTips收集

@[TOC]

## TODO

- [ ] 列表的切片操作;

## 格式约束

请参考`文件操作`下的`Tips01_获取文件的绝对路径`.

## 字符串和文本

### Tips01_生成随机数

- **方法1：** 一般操作

``` python
import string
import random

# 固定长度：
alphabet = string.ascii_letters + string.digits
password = ''.join(choice(alphabet) for i in range(8))
# range里面可以random.randint(5, 10)设定可变长度
```

- **方法2：** 使用secrets，异常方便。[更多..](https://docs.python.org/3/library/secrets.html)

``` python
import secrets

# 随机生成[0,n)的int
secrets.randbelow(10)
# 随机字符串，还包含符号
secrets.token_urlsafe(10)
输出：'Drmhze6EPcv0fN_81Bj-nA'
```

### Tips02_大小写转换

``` python
print(str.upper())          # 把所有字符中的小写字母转换成大写字母
print(str.lower())          # 把所有字符中的大写字母转换成小写字母
print(str.capitalize())     # 把第一个字母转化为大写字母，其余小写
print(str.title())          # 把每个单词的第一个字母转化为大写，其余小写
```

### Tipe03_字符切片

- `data[x:y]`：第一索引号码是片的开始（含），并且所述第二索引号码是片的端部（不包括）。

``` python
data = 'abcdefg'
data[1:4]
data[1:]

输出:
'bcd'
'bcdefg'
```

- `data[x:y:z]`：第三个索引号码代表跨度，默认为1。取所有内容可以省略前面两个索引，例如：

``` python
data = 'abcdefg'
data[::2]

输出：
'aceg'
```

- `data[-x:-y:-z]`：首先需要改变z，也就是先转变方向。然后再调整-x和-y，例如：

``` python
data = 'abcdefg'
data[-1::]
data[::-1]
data[-1:-4:-1]
data[-1:-6:-2]

输出：
'g'
'abcdefg'
'gfe'
'gec'
```

## 列表和字典

同样还包括衍生的: 元组、集合..

### Tips01_查找最大最小值,以及排序

**场景-1**:

使用heapq模块的两个函数`nlargest()`和`nsmallest()`可以解决(方法前面的n代表number..), 请见演示1和2.

如果只是获取列表中的最大一个或者最小一个item, 则可以使用`max()`和`min()`更快点.

**场景-2**:

使用heapq的`heapify()`函数可将列表变为一个从小到大排序的列表.

如果需要排序, 使用`sorted(item)[:N]`或者`sorted(item)[-N:]`更好些.

**演示-1**:

``` python
import heapq

nums = [2, 5, 3, 6, 7, 8, 8, 20]
print(heapq.nlargest(3, nums))
# OUT:
[20, 8, 8]

print(heapq.nsmallest(2, nums))
# OUT:
[2, 3]
```

**演示-2**: 对复杂函数可以指定其中的一个参数进行排序(或者取出其中最大的几个)

``` python
import heapq

data = [
    {'name': 'zhangsan', 'age': 18, 'salary': 1000},
    {'name': 'lisi', 'age': 24, 'salary': 3000},
    {'name': 'wangwu', 'age': 34, 'salary': 8000},
]
print(heapq.nsmallest(1, data, key=lambda d: d['age']))
# OUT:
[{'salary': 1000, 'age': 18, 'name': 'zhangsan'}]

# 如果指定的数量与列表大小相等, 那么就是sort排序了
print(heapq.nsmallest(len(data), data, key=lambda d: d['age']))
# OUT:
[{'salary': 1000, 'age': 18, 'name': 'zhangsan'},
{'salary': 3000, 'age': 24, 'name': 'lisi'},
{'salary': 8000, 'age': 34, 'name': 'wangwu'}]
# 当然largest同样支持该操作, 这里就不赘述了
```

### Tips02_创建有序字典

**场景-1**:

想创建一个字典, 并且保证字典能够控制元素的排序. 可以使用collections模块中的`OrderedDict`类来实现.

对于使用yaml作为配置文件的话会使用dict反序列化, 结果导致配置文件会乱序, 可以使用这个方法解决.

**演示-1**:

``` python
from collections import OrderedDict

d = OrderedDict()
d['a'] = 1,
d['b'] = 2,
d['c'] = 3,
d['d'] = 4,
for key in d:
    print(key, d[key])
# OUT:
('a', (1,))
('b', (2,))
('c', (3,))
('d', (4,))
# 如果: d = dict(), OUT:
('a', (1,))
('c', (3,))
('b', (2,))
('d', (4,))
```

## 函数

### Tips01_判断变量是否为函数

**场景:** 判断变量是否为函数，是函数才执行，不是则丢弃。

``` python
# 某些比较特殊的函数没办法判断，type结果都不是function
>>> import time
>>> type(time.time)
<class 'builtin_function_or_method'>

# 因此先把他做成方法哈哈
>>> def func():
...     return time.time()
>>> type(func)
<class 'function'>

# 意图是传到一个dict中，需要他执行的时候再执行
data = {
  'test': func
}
```

**方法1:** (已不推荐，为啥请[移步..](https://cloud.tencent.com/developer/ask/26439))

``` python
>>> import types
>>> if isinstance(data['test'], types.FunctionType):
...     print(True)
...
True
# 这时候就能在print的位置执行：
# data['test']()
# 获取到当前的时间戳了
```

**方法2:** 这种方法是python3的，而且不用`import types`，并且语法更精炼。

``` python
>>> callable(data['test'])
True
```

**:warning: 注意：** 如果这是针对Python 3.x，但在3.2之前，请检查该对象是否具有`__call__`属性。你可以这样做：

``` python
>>> hasattr(data['func'], '__call__')
True
```

### Tips02_装饰器用法

**格式1：** 单个装饰器

``` python
def decorator(func):  # func为形参，可自定义
    def wrapper(name):  # 这里被装饰函数是啥就要传入一致的参数
        func(name)  # 这里可以直接调用
        print('nice to meet you')
    return wrapper  # 这里返回内部函数，但是函数不能带()，是不能执行的

@decorator  # 装饰器的名字，可自定义
def some_func(name):  # 要装饰的函数
    print(name)

some_func('my name is')  # 这里才正儿八经执行了
```

**格式1.1** 单个装饰器(带返回值)

Demo: [day15_decorator.py](https://github.com/billxllid/python_learn/blob/master/day15_decorator.py)

``` python
def decorator(func):
    def inner(a, b):
        print('add >> something here.')
        result = func(a, b)
        print('add >> another here.')
        return result
    return inner


@decorator
def hello_world(a, b):
    if a == b:
        print('hello >> a like b!')
        return True
    else:
        print('hello >> a unlike b..')
        return False


a = 1
b = 0
output = hello_world(a, b)
print('return >>', output)

# OUT:
add >> something here.
hello >> a unlike b..
add >> another here.
return >> False
```

**格式2：** 多个装饰器

``` python
def decorator(func):
    def wrapper():
        func()
        print('decorator 01')
    return wrapper

def decorator2(func):
    def wrapper():
        func()
        print('decorator 02')
    return wrapper

@decorator
@decorator2
def some_func():
    print('helloworld')

some_func()
```

**格式3：** 带可变参数

``` python
def decorator(func):
    def wrapper(message, *args, **kargs):
        func(message, *args, **kargs)
        print('nice to meet you')
        print('装饰器处理过的message:{}'.format(message))
    return wrapper

@decorator
def some_func(message, *args, **kargs):
    print(message)
    for i in args:
        print(i)

    print(kargs)

list_data = ['a', 'b', 'c']
dict_data = {
    'd': '1',
    'e': '2'
}

# 单个传入也可以，kargs则为{}
# some_func('单个可变参数:', *list_data)
some_func('多个可变参数:', *list_data, **dict_data)
```

**格式4：** 装饰类中的函数

``` python
# 注意这里必须在类外面
def make_more_pretty(func):
    def inner(self):  # 这里要将self传过来
        func(self)  # 同样
        print('Fine')
    return inner

class A:
    @make_more_pretty
    def some_func(self):
        print('hello world')

a = A()
a.some_func()
```

**格式5：** 附加参数(貌似没办法传变量)

``` python
def update(update):
    def decorator(func):
        print(update)
        def wrapper(message, *args, **kargs):
            func(message, *args, **kargs)
            print('nice to meet you')
            print('装饰器处理过的message:{}'.format(message))
        return wrapper
    return decorator

@update('update')  # 这里decorator换update
def some_func(message, *args, **kargs):
    print(message)
    for i in args:
        print(i)
    print(kargs)


list_data = ['a', 'b', 'c']
dict_data = {
    'd': '1',
    'e': '2'
}

# some_func('单个可变参数:', *list_data)
some_func('多个可变参数:', *list_data, **dict_data)
```

**用途demo：** 设定初始值，或者保持一个变量的值

可以用来让上层函数（指closing函数）的变量持久化（设置个初值或者定值）。

``` python
def foo(x):
    def bar(var):
        return x + var
    return bar

# 我一开始有10ml牛奶和20ml水
water = foo(10)
milk = foo(20)

# 我各买20ml, 现在我有30ml水，40ml牛奶
# 初始值被保留了
print(water(20))
print(milk(20))

# 因此这个方法可以用于设置初值
```

### Tips03_令局部变量外部可访问

如何让局部变量变得外层可以访问

``` python
def outer_function():
    a = 5
    def inner_function():
        nonlocal a  # 关键在于这个
        a = 10
        print("Inner function: ",a)
    inner_function()
    print("Outer function: ",a)

outer_function()

输出：
Inner function:  10
Outer function:  5
```

### Tips04_异常处理原则

**语法格式：** 如下图：

{% asset_img 2018-07-02-00-04-58.png 异常处理语法格式 %}

**流程：** 如下图：

{% asset_img 2018-07-02-00-16-04.png 异常处理流程图 %}

## 文件操作

### Tips01_获取文件的绝对路径

**参考**: [python获取文件的绝对路径 - CSDN博客](https://blog.csdn.net/lom9357bye/article/details/79285170)

使用类中的`__file__`属性

```python
current_dir = os.path.dirname(__file__)
```

或者, 使用`inspect`下的`getfile()`获取到当前文件的绝对路径, 然后在通过`os.path.dirname`获取到当前文件所在的路径.

``` python
import inspect
import os

current_dir = os.path.dirname(inspect.getfile(inspect.currentframe()))
```

后面可以使用os.path拼接相对路径

``` python
self.path = os.path.join(current_dir, 'conf/demo_yaml.yml')
```

**实际案例**: 配置文件的读取.

在跨目录引用父类的场景中, 如果父类中使用了相对路径的方式获取文件路径, 则子类在触发相关动作的时候会出现"FileNotFound"错误, 因此需要在父类中使用绝对路径获取文件路径.

例如当前项目的目录结构如下:

```
conf/
    default.ini  # 表示conf/defult.ini, 下同
script/
    child.py
father.py
```

`father.py`中有对default.ini配置文件的引用动作:

``` python
class Father:

    def __init__(self):
        self.path = 'conf/default.ini'  # !!这里

    def read(self):
        with open(self.path, 'r') as f:
            for line in f:
                pass
            print('read!!')
```

`child.py`中继承了父类, 并且想要调用父类的read()方法:

``` python
from test_import import Father


class Child(Father):
    def __init__(self):
        super(Child, self).__init__()

    def run(self):
        self.read()

    def get_path(self):
        return self.path


if __name__ == '__main__':
    child = Child()
    path = child.get_path()
    # print(path)
    child.run()  # 这里是封装了一下..实际上还是调用了父类方法
```

执行会报错:

```
FileNotFoundError: [Errno 2] No such file or directory: 'conf/default.ini'
```

原因自然是程序不会以father的目录为当前目录, 而是以child的, 所以找不到conf目录

**解决方案**:

解决方案就是要在父类中获取到文件的绝对路径, 这样父类就能找到文件了.

修改后的`father.py`如下:

``` python
class Father:

    def __init__(self):
        #self.path = 'conf/default.ini'
        current_dir = os.path.dirname(__file__)
        self.path = os.path.join(current_dir, 'conf/default.yml')
    ...
```

## 其他

### Tips01_HTTP_HEAD_UA构建

``` python
from urllib.parse import urlparse as parsy
...

user_agents = ['Mozilla/5.0 (X11; Linux i686; rv:60.0) Gecko/20100101 Firefox/60.0',
'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36'
'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36 OPR/43.0.2442.991']

 headers = {
    'Host' : parsy(url).hostname,
    'User-Agent' : random.choice(user_agents),
    'Accept' : 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
    'Accept-Language' : 'en-US,en;q=0.5',
    'Accept-Encoding' : 'deflate',
    'Connection' : 'close',
    'DNT' : '1',
    'Connection' : 'close'}
```

### Tips02_控制台字体颜色

最后几个是比较常用打赢日志的类别标识，了解一下。

```
white = '\033[97m'
green = '\033[92m'
red = '\033[91m'
yellow = '\033[93m'
end = '\033[0m'
back = '\033[7;91m'
info = '\033[33m[!]\033[0m'
que = '\033[34m[?]\033[0m'
bad = '\033[31m[-]\033[0m'
good = '\033[32m[+]\033[0m'
run = '\033[97m[~]\033[0m'
```

典型的bash颜色

```
print('\033[1;97m things... \033[0m')
```

## 声明

**版权：** 2018-now，:cn:，zangjiaao\<zangjiaao@yahoo.com>

由家浩创作并维护的`zangjiaao's blog`博客所有文章除特别声明外，均采用"署名-非商业性使用-相同方式共享4.0(CC BY-NC-SA 4.0)[国际许可证](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)"。

本文首发于[zangjiaao's blog](https://blog.zangjiaao.cn/)博客，转载请注明出处。
