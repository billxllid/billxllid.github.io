---
title: Python技巧
categories: '04_学习笔记'
tags:
  - python
  - 速查
date: 2018-06-22 00:09:52
---

{% asset_path 20180622-Python技巧 %}

**概述：** python的一些Tips，浓缩都是精华啊...

 <!-- more -->

# PythonTips收集

@[TOC]

## 字符串和文本

### Tips01_生成随机数

- **方法1：** 一般操作

``` python
import string
import random

# 固定长度：
alphabet = string.ascii_letters + string.digits
password = ''.join(choice(alphabet) for i in range(8))
# range里面可以random.randint(5, 10)设定可变长度
```

- **方法2：** 使用secrets，异常方便。[更多..](https://docs.python.org/3/library/secrets.html)

``` python
import secrets

# 随机生成[0,n)的int
secrets.randbelow(10)
# 随机字符串，还包含符号
secrets.token_urlsafe(10)
输出：'Drmhze6EPcv0fN_81Bj-nA'
```

### Tips02_大小写转换

``` python
print(str.upper())          # 把所有字符中的小写字母转换成大写字母
print(str.lower())          # 把所有字符中的大写字母转换成小写字母
print(str.capitalize())     # 把第一个字母转化为大写字母，其余小写
print(str.title())          # 把每个单词的第一个字母转化为大写，其余小写
```

### Tipe03_字符切片

- `data[x:y]`：第一索引号码是片的开始（含），并且所述第二索引号码是片的端部（不包括）。

``` python
data = 'abcdefg'
data[1:4]
data[1:]

输出:
'bcd'
'bcdefg'
```

- `data[x:y:z]`：第三个索引号码代表跨度，默认为1。取所有内容可以省略前面两个索引，例如：

``` python
data = 'abcdefg'
data[::2]

输出：
'aceg'
```

- `data[-x:-y:-z]`：首先需要改变z，也就是先转变方向。然后再调整-x和-y，例如：

``` python
data = 'abcdefg'
data[-1::]
data[::-1]
data[-1:-4:-1]
data[-1:-6:-2]

输出：
'g'
'abcdefg'
'gfe'
'gec'
```

## 函数

### Tips01_判断变量是否为函数

**场景:** 判断变量是否为函数，是函数才执行，不是则丢弃。

``` python
# 某些比较特殊的函数没办法判断，type结果都不是function
>>> import time
>>> type(time.time)
<class 'builtin_function_or_method'>

# 因此先把他做成方法哈哈
>>> def func():
...     return time.time()
>>> type(func)
<class 'function'>

# 意图是传到一个dict中，需要他执行的时候再执行
data = {
  'test': func
}
```

**方法1:** (已不推荐，为啥请[移步..](https://cloud.tencent.com/developer/ask/26439))

``` python
>>> import types
>>> if isinstance(data['test'], types.FunctionType):
...     print(True)
...
True
# 这时候就能在print的位置执行：
# data['test']()
# 获取到当前的时间戳了
```

**方法2:** 这种方法是python3的，而且不用`import types`，并且语法更精炼。

``` python
>>> callable(data['test'])
True
```

**:warning: 注意：** 如果这是针对Python 3.x，但在3.2之前，请检查该对象是否具有`__call__`属性。你可以这样做：

``` python
>>> hasattr(data['func'], '__call__')
True
```

### Tips02_装饰器用法

**格式1：** 单个装饰器

``` python
def decorator(func):  # func为形参，可自定义
    def wrapper(name):  # 这里被装饰函数是啥就要传入一致的参数
        func(name)  # 这里可以直接调用
        print('nice to meet you')
    return wrapper  # 这里返回内部函数，但是函数不能带()，是不能执行的

@decorator  # 装饰器的名字，可自定义
def some_func(name):  # 要装饰的函数
    print(name)

some_func('my name is')  # 这里才正儿八经执行了
```

**格式1.1** 单个装饰器(带返回值)

Demo: [day15_decorator.py](https://github.com/billxllid/python_learn/blob/master/day15_decorator.py)

``` python
def decorator(func):
    def inner(a, b):
        print('add >> something here.')
        result = func(a, b)
        print('add >> another here.')
        return result
    return inner


@decorator
def hello_world(a, b):
    if a == b:
        print('hello >> a like b!')
        return True
    else:
        print('hello >> a unlike b..')
        return False


a = 1
b = 0
output = hello_world(a, b)
print('return >>', output)

# OUT:
add >> something here.
hello >> a unlike b..
add >> another here.
return >> False
```

**格式2：** 多个装饰器

``` python
def decorator(func):
    def wrapper():
        func()
        print('decorator 01')
    return wrapper

def decorator2(func):
    def wrapper():
        func()
        print('decorator 02')
    return wrapper

@decorator
@decorator2
def some_func():
    print('helloworld')

some_func()
```

**格式3：** 带可变参数

``` python
def decorator(func):
    def wrapper(message, *args, **kargs):
        func(message, *args, **kargs)
        print('nice to meet you')
        print('装饰器处理过的message:{}'.format(message))
    return wrapper

@decorator
def some_func(message, *args, **kargs):
    print(message)
    for i in args:
        print(i)

    print(kargs)

list_data = ['a', 'b', 'c']
dict_data = {
    'd': '1',
    'e': '2'
}

# 单个传入也可以，kargs则为{}
# some_func('单个可变参数:', *list_data)
some_func('多个可变参数:', *list_data, **dict_data)
```

**格式4：** 装饰类中的函数

``` python
# 注意这里必须在类外面
def make_more_pretty(func):
    def inner(self):  # 这里要将self传过来
        func(self)  # 同样
        print('Fine')
    return inner

class A:
    @make_more_pretty
    def some_func(self):
        print('hello world')

a = A()
a.some_func()
```

**格式5：** 附加参数(貌似没办法传变量)

``` python
def update(update):
    def decorator(func):
        print(update)
        def wrapper(message, *args, **kargs):
            func(message, *args, **kargs)
            print('nice to meet you')
            print('装饰器处理过的message:{}'.format(message))
        return wrapper
    return decorator

@update('update')  # 这里decorator换update
def some_func(message, *args, **kargs):
    print(message)
    for i in args:
        print(i)
    print(kargs)


list_data = ['a', 'b', 'c']
dict_data = {
    'd': '1',
    'e': '2'
}

# some_func('单个可变参数:', *list_data)
some_func('多个可变参数:', *list_data, **dict_data)
```

**用途demo：** 设定初始值，或者保持一个变量的值

可以用来让上层函数（指closing函数）的变量持久化（设置个初值或者定值）。

``` python
def foo(x):
    def bar(var):
        return x + var
    return bar

# 我一开始有10ml牛奶和20ml水
water = foo(10)
milk = foo(20)

# 我各买20ml, 现在我有30ml水，40ml牛奶
# 初始值被保留了
print(water(20))
print(milk(20))

# 因此这个方法可以用于设置初值
```

### Tips03_令局部变量外部可访问

如何让局部变量变得外层可以访问

``` python
def outer_function():
    a = 5
    def inner_function():
        nonlocal a  # 关键在于这个
        a = 10
        print("Inner function: ",a)
    inner_function()
    print("Outer function: ",a)

outer_function()

输出：
Inner function:  10
Outer function:  5
```

### Tips04_异常处理原则

**语法格式：** 如下图：

{% asset_img 2018-07-02-00-04-58.png 异常处理语法格式 %}

**流程：** 如下图：

{% asset_img 2018-07-02-00-16-04.png 异常处理流程图 %}

## 其他

### Tips01_HTTP_HEAD_UA构建

``` python
from urllib.parse import urlparse as parsy
...

user_agents = ['Mozilla/5.0 (X11; Linux i686; rv:60.0) Gecko/20100101 Firefox/60.0',
'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36'
'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36 OPR/43.0.2442.991']

 headers = {
    'Host' : parsy(url).hostname,
    'User-Agent' : random.choice(user_agents),
    'Accept' : 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
    'Accept-Language' : 'en-US,en;q=0.5',
    'Accept-Encoding' : 'deflate',
    'Connection' : 'close',
    'DNT' : '1',
    'Connection' : 'close'}
```

### Tips02_控制台字体颜色

最后几个是比较常用打赢日志的类别标识，了解一下。

```
white = '\033[97m'
green = '\033[92m'
red = '\033[91m'
yellow = '\033[93m'
end = '\033[0m'
back = '\033[7;91m'
info = '\033[33m[!]\033[0m'
que = '\033[34m[?]\033[0m'
bad = '\033[31m[-]\033[0m'
good = '\033[32m[+]\033[0m'
run = '\033[97m[~]\033[0m'
```

典型的bash颜色

```
print('\033[1;97m things... \033[0m')
```

## 声明

**版权：** 2018-now，:cn:，zangjiaao\<zangjiaao@yahoo.com>

由家浩创作并维护的`zangjiaao's blog`博客所有文章除特别声明外，均采用"署名-非商业性使用-相同方式共享4.0(CC BY-NC-SA 4.0)[国际许可证](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)"。

本文首发于[zangjiaao's blog](https://blog.zangjiaao.cn/)博客，转载请注明出处。
