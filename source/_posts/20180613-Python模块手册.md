---
title: Python模块手册
categories: '04_学习笔记'
tags:
  - python
date: 2018-06-13 20:38:11
---

**概述：** 主要用于备忘，记录一些我常用到的一些类的Tips和特性(*基于python3)..[官方的ApiDoc](https://docs.python.org/3/library/re.html)..

 <!-- more -->

# Python模块手册

@[TOC]

## TODO

- [ ] paramiku(SSH远程管理)

## paramiku(SSH远程)

主要参考[这篇文章](http://mingxinglai.com/cn/2015/06/paramiko/).

### 安装

``` bash
sudo pip instal paramiko
```

### 建立连接

- connect api 全部参数： ([官方api文档](https://paramiko-docs.readthedocs.io/en/1.15/api/client.html#paramiko.client.SSHClient.load_system_host_keys)):

``` python
connect(hostname, port=22,
username=None, password=None,
pkey=None, key_filename=None,
timeout=None, allow_agent=True,
look_for_keys=True, compress=False,
sock=None, gss_auth=False, gss_kex=False,
gss_deleg_creds=True, gss_host=None,
banner_timeout=None, auth_timeout=None,
gss_trust_dns=True)
```

- 使用密码:

``` python
import paramiko
ssh = paramiko.SSHClient()
#这行代码的作用是允许连接不在know_hosts文件中的主机。
ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
ssh.connect("IP",  port, "username", "password")
```

- 使用密钥对:

``` python
ssh = paramiko.SSHClient()
ssh.connect('10.120.48.109', port, '用户名',
key_filename='私钥')
```

### 执行命令

- 单条执行：exec

``` python
exec_command(command, bufsize=-1,
timeout=None, get_pty=False,
environment=None)
```

``` python
stdin, stdout, stderr = client.exec_command('ls -l')
print(stdout.readlines())
```

- 交互式：ssh.invoke_shell()

``` python
# Start an interactive shell session on the SSH server.
channel = ssh.invoke_shell()
# 随后官方文档可以切换到channel章节观看了
if not recv_ready():
    return('连接未就绪')
channel.send('su - billx' + '\n')
# recv会读取buff中的str/bytes类型数据
# 这里指定的9999代表buff的最大字节数
buff = channel.recv(9999)
print(buff)
# 所有命令执行完成后关闭
channel.close()
```

## configparser(配置文件)

参考：[14.2. configparser — Configuration file parser &#8212; Python 3.6.6rc1 documentation](https://docs.python.org/3/library/configparser.html)。

### 创建配置文件

``` python
import configparser
config = configparser.ConfigParser()
# 创建空分类
config['EMPTY'] = {}
# 赋值
config['EMPTY']['test'] = 'test'
# 优雅方式赋值..
x = config['EMPTY']
x['test2'] = 'test2'
# 创建时直接赋值..
config['DEFAULT'] = {
    'test3': 'test3',
    'test4': 'test4',
}
# 修改
config['DEFAULT']['test4'] = 'test5'
# 写入文件
with open('test_pyconfig.ini', 'w') as configfile:
    config.write(configfile)
```

**成品:**

``` ini
# test_pyconfig.ini
[DEFAULT]
test3 = test3
test4 = test5

[EMPTY]
test = test
test2 = test2
```

## logging(日志)

[python logging模块使用教程](https://www.jianshu.com/p/feb86c06c4f4)

## pymysql(mysql连接器)

### 常规流程

``` python
import pymysql

# 建立连接

conn = pymysql.connect(
  host = 'localhost',
  port = 3306,
  user = 'tester',
  passwd = 'qwe123',
  db = 'test',
  charset = 'utf8'
)

# 创建游标

try:
    cursor = connect.cursor()
except pymysql.MySQLError as e:
    print('Connect error. Detail: %s' % str(e))

# 构建SQL语句

sql = """
SELECT VERSION()
"""

# 执行

try:
    cursor.execute(sql)
except pymysql.ProgrammingError as e:
    print(e)
    exit()

# 获取响应

r = cursor.fetchall()
print(r)

# INSERT、UPDATE需要commit()，否则无法实际修改数据

conn.commit()

# 关闭游标和连接

cursor.close()
conn.close()
```

### with简化连接

免得每次都要`conn.close()`

```
# 使用with简化连接过程，每次都连接关闭很麻烦，使用上下文管理，简化连接过程
import pymysql
import contextlib


# 定义上下文管理器，连接后自动关闭连接
@contextlib.contextmanager
def mysql(host='127.0.0.1', port=3306, user='blog', passwd='123456', db='blog', charset='utf8'):
    conn = pymysql.connect(host=host, port=port, user=user, passwd=passwd, db=db, charset=charset)
    cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)
    try:
        yield cursor
    finally:
        conn.commit()
        cursor.close()
        conn.close()

# 执行sql
with mysql() as cursor:
    # 左连接查询
    r = cursor.execute("select * from users as u left join articles as a on u.id = a.user_id where a.user_id = 2")
    result = cursor.fetchall()
    print(result)
```

### 防SQL注入

- **参数化查询**

内部执行参数化生成的SQL语句，对特殊字符进行了加`\`转义，避免注入语句生成。

``` python
cursor.execute("""
select username,password
from tb7
where username=%s and password=%s""", (username, password))

# 或者将sql语句与data拆分也可以
sql = """
 ...
"""
data = ( .. ,)
cursor.execute(sql, data)
```

在插入多行数据时，使用`executemay`效果要更好。

``` python
cursor.executemany("""
INSERT INTO user(
    username,
    userpass,
    email
)VALUE(%s, %s, %s)
""", [('A', '123', '123@qq.com'), ('B', '456', '456@qq.com')])
```

- **存储过程**

``` python
sql1="select * from users where nid>? and nid<?"
cursor.callproc('proc_sql', args=(11, 15, sql1))
```

更多详见[python中操作mysql的pymysql模块详解](https://www.jianshu.com/p/f11508c98e62)。

### 查询数据获取

``` python
# 获取第一行数据
row_1 = cursor.fetchone()

# 获取前n行数据
row_n = cursor.fetchmany(3)

# 获取所有数据
row_3 = cursor.fetchall()
```

### 获取最新自增ID

``` python
new_id = cursor.lastrowid
```

### 游标操控

``` python
# 相对当前位置移动
cursor.scroll(1,mode='relative')

# 相对绝对位置移动
cursor.scroll(2,mode='absolute')
```

### 错误回滚

``` python
try:
   cursor.execute(sql)
   conn.commit()
except:

   # 如果发生错误则回滚

   conn.rollback()
```

### 调用存储过程

- **无参存储过程**

``` python
#游标设置为字典类型
cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)

#等价于cursor.execute("call p2()")
cursor.callproc('p2')

row_1 = cursor.fetchone()
print(row_1)
```

- **有参存储过程**

``` python
cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)

cursor.callproc('p1', args=(1, 22, 3, 4))

# 获取执行完存储的参数,参数@开头
cursor.execute("select @p1,@_p1_1,@_p1_2,@_p1_3")

# {u'@_p1_1': 22, u'@p1': None, u'@_p1_2': 103, u'@_p1_3': 24}
row_1 = cursor.fetchone()
print(row_1)
```

### 异常处理

请参考[pymysql异常处理](http://www.runoob.com/python3/python3-mysql.html)文末。

## argparse(用户传参)

可以用`argparse`替代原来的`getparse`以及`optparse`了。

更多方法可以通过help()以及[PEP 389 -- argparse - New Command Line Parsing Module](https://www.python.org/dev/peps/pep-0389/#updates-to-getopt-documentation)获取。

``` python
import argparse

def get_parser():
    parser = argparse.ArgumentParser(description='scanless, public port scan scrapper')
    parser.add_argument('-v', '--version', help='display the current version',
                        action='store_true')
    parser.add_argument('-t', '--target', help='ip or domain to scan',
                        type=str)
    parser.add_argument('-s', '--scanner', help='scanner to use (default: hackertarget)',
                        type=str, default='hackertarget')
    return parser

def main():
    parser = get_parser()
    args = vars(parser.parse_args())

if __name__ == '__main__':
    main()
```

## 声明

**版权：** 2018-now，:cn:，zangjiaao\<zangjiaao@yahoo.com>

由家浩创作并维护的`zangjiaao's blog`博客所有文章除特别声明外，均采用"署名-非商业性使用-相同方式共享4.0(CC BY-NC-SA 4.0)[国际许可证](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)"。

本文首发于[zangjiaao's blog](https://blog.zangjiaao.cn/)博客，转载请注明出处。
