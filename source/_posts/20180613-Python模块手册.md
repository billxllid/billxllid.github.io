---
title: Python模块手册
categories: '04_学习笔记'
tags:
  - python
date: 2018-06-13 20:38:11
---

**概述：** 主要用于备忘，记录一些我常用到的一些类的Tips和特性(*基于python3)..[官方的ApiDoc](https://docs.python.org/3/library/re.html)..

 <!-- more -->

# Python模块手册

@[TOC]

## TODO

## paramiku(SSH控制端)

1. 参考这篇[文章](http://mingxinglai.com/cn/2015/06/paramiko/).
2. 官方API[文档](https://paramiko-docs.readthedocs.io/en/2.4/api/sftp.html).

### 安装

``` bash
sudo pip instal paramiko
```

### 初始化连接

``` python
import paramiko

ssh = paramiko.SSHClient()

#允许连接到不在本机know_hosts中的主机
ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())

# 以密钥对方式建立:
ssh_client.connect("IP",  port, username="username", password="password")

# 以密钥对方式建立:
ssh.connect('IP',port, '用户名', key_filename='/home/xxx/.ssh/id_rsa', passphrase='xxx')
```

可执行单条命令,通过传统std接收输入输出,以及error:

``` python
stdin, stdout, stderr = ssh_client.exec_command('ls -l')
print(stdout.readlines())
```

### 建立channel

``` python
with ssh_client.invoke_shell() as ssh_channel:
    ssh_channel.send('whoami\n')
    buff = ssh_channel.recv(999)


channel = ssh.invoke_shell()
if not recv_ready():
    return('连接未就绪')
channel.send('su - billx' + '\n')
buff = channel.recv(9999)
print(buff)
channel.close()
```

### 最佳实践

#### su方式运行

``` python
import paramiko
import time
import copy
import re

ssh_client = paramiko.SSHClient()
ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
ssh_client.connect('192.168.56.101', username='billx', password='qwe123')

def exec_cmd(cmd):
    with ssh_client.invoke_shell() as chann:
        while not chann.recv_ready():
            time.sleep(1)
            print('delayA..')
        while chann.recv_ready():
            chann.recv(1024)

        su_pwd = 'qwe123'
        chann.send('su - root\n')
        while not chann.recv_ready():
            time.sleep(1)
            print('delayB..')
        chann.send(su_pwd + '\n')
        while not chann.recv_ready():
            time.sleep(1)
            print('delayC..')
        while chann.recv_ready():
            data = chann.recv(1024)
        

        chann.send(cmd + '\n')
        while not chann.recv_ready():
            time.sleep(1)
            print('delayD..')

        data = b''
        while True:
            if not chann.recv_ready():
                data = filter(lambda x: not re.match('\[.*?][#$]\s+$', x),
                              data.decode().split('\r\n')[1:])
                print('\n'.join(data))
                break
            tmp = chann.recv(1024)
            data += tmp

cmd = 'ss -tulnap'
exec_cmd(cmd)

print('\ndone..\n')

cmd = 'pwd'
exec_cmd(cmd)

```

## logging(日志)

[python logging模块使用教程](https://www.jianshu.com/p/feb86c06c4f4)

## pymysql(mysql客户端)

### 常规流程

``` python
import pymysql

# 建立连接

conn = pymysql.connect(
  host = 'localhost',
  port = 3306,
  user = 'tester',
  passwd = 'qwe123',
  db = 'test',
  charset = 'utf8'
)

# 创建游标

try:
    cursor = connect.cursor()
except pymysql.MySQLError as e:
    print('Connect error. Detail: %s' % str(e))

# 构建SQL语句

sql = """
SELECT VERSION()
"""

# 执行

try:
    cursor.execute(sql)
except pymysql.ProgrammingError as e:
    print(e)
    exit()

# 获取响应

r = cursor.fetchall()
print(r)

# INSERT、UPDATE需要commit()，否则无法实际修改数据

conn.commit()

# 关闭游标和连接

cursor.close()
conn.close()
```

### with简化连接

免得每次都要`conn.close()`

```
# 使用with简化连接过程，每次都连接关闭很麻烦，使用上下文管理，简化连接过程
import pymysql
import contextlib


# 定义上下文管理器，连接后自动关闭连接
@contextlib.contextmanager
def mysql(host='127.0.0.1', port=3306, user='blog', passwd='123456', db='blog', charset='utf8'):
    conn = pymysql.connect(host=host, port=port, user=user, passwd=passwd, db=db, charset=charset)
    cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)
    try:
        yield cursor
    finally:
        conn.commit()
        cursor.close()
        conn.close()

# 执行sql
with mysql() as cursor:
    # 左连接查询
    r = cursor.execute("select * from users as u left join articles as a on u.id = a.user_id where a.user_id = 2")
    result = cursor.fetchall()
    print(result)
```

### 防SQL注入

- **参数化查询**

内部执行参数化生成的SQL语句，对特殊字符进行了加`\`转义，避免注入语句生成。

``` python
cursor.execute("""
select username,password
from tb7
where username=%s and password=%s""", (username, password))

# 或者将sql语句与data拆分也可以
sql = """
 ...
"""
data = ( .. ,)
cursor.execute(sql, data)
```

在插入多行数据时，使用`executemay`效果要更好。

``` python
cursor.executemany("""
INSERT INTO user(
    username,
    userpass,
    email
)VALUE(%s, %s, %s)
""", [('A', '123', '123@qq.com'), ('B', '456', '456@qq.com')])
```

- **存储过程**

``` python
sql1="select * from users where nid>? and nid<?"
cursor.callproc('proc_sql', args=(11, 15, sql1))
```

更多详见[python中操作mysql的pymysql模块详解](https://www.jianshu.com/p/f11508c98e62)。

### 查询数据获取

``` python
# 获取第一行数据
row_1 = cursor.fetchone()

# 获取前n行数据
row_n = cursor.fetchmany(3)

# 获取所有数据
row_3 = cursor.fetchall()
```

### 获取最新自增ID

``` python
new_id = cursor.lastrowid
```

### 游标操控

``` python
# 相对当前位置移动
cursor.scroll(1,mode='relative')

# 相对绝对位置移动
cursor.scroll(2,mode='absolute')
```

### 错误回滚

``` python
try:
   cursor.execute(sql)
   conn.commit()
except:

   # 如果发生错误则回滚

   conn.rollback()
```

### 调用存储过程

- **无参存储过程**

``` python
#游标设置为字典类型
cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)

#等价于cursor.execute("call p2()")
cursor.callproc('p2')

row_1 = cursor.fetchone()
print(row_1)
```

- **有参存储过程**

``` python
cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)

cursor.callproc('p1', args=(1, 22, 3, 4))

# 获取执行完存储的参数,参数@开头
cursor.execute("select @p1,@_p1_1,@_p1_2,@_p1_3")

# {u'@_p1_1': 22, u'@p1': None, u'@_p1_2': 103, u'@_p1_3': 24}
row_1 = cursor.fetchone()
print(row_1)
```

### 异常处理

请参考[pymysql异常处理](http://www.runoob.com/python3/python3-mysql.html)文末。

## argparse(用户传参控制)

可以用`argparse`替代原来的`getparse`以及`optparse`了。

更多方法可以通过help()以及[PEP 389 -- argparse - New Command Line Parsing Module](https://www.python.org/dev/peps/pep-0389/#updates-to-getopt-documentation)获取。

``` python
import argparse

def get_parser():
    parser = argparse.ArgumentParser(description='scanless, public port scan scrapper')
    parser.add_argument('-v', '--version', help='display the current version',
                        action='store_true')
    parser.add_argument('-t', '--target', help='ip or domain to scan',
                        type=str)
    parser.add_argument('-s', '--scanner', help='scanner to use (default: hackertarget)',
                        type=str, default='hackertarget')
    return parser

def main():
    parser = get_parser()
    args = vars(parser.parse_args())

if __name__ == '__main__':
    main()
```

## configparser(配置文件控制)

参考：[14.2. configparser — Configuration file parser &#8212; Python 3.6.6rc1 documentation](https://docs.python.org/3/library/configparser.html)。

### 创建

``` python
import configparser
config = configparser.ConfigParser()
# 创建空分类
config['EMPTY'] = {}
# 赋值
config['EMPTY']['test'] = 'test'
# 优雅方式赋值..
x = config['EMPTY']
x['test2'] = 'test2'
# 创建时直接赋值..
config['DEFAULT'] = {
    'test3': 'test3',
    'test4': 'test4',
}
# 修改
config['DEFAULT']['test4'] = 'test5'
# 写入文件
with open('test_pyconfig.ini', 'w') as configfile:
    config.write(configfile)
```

生成如下配置文件:

``` ini
# test_pyconfig.ini
[DEFAULT]
test3 = test3
test4 = test5

[EMPTY]
test = test
test2 = test2
```

### 读取

``` python
import configparser

config = configparser.ConfigParser()
config.read('example.ini')
```

### 传统模式(更高级)

创建

``` python
import configparser

config = configparser.RawConfigParser()

# Please note that using RawConfigParser's set functions, you can assign
# non-string values to keys internally, but will receive an error when
# attempting to write to a file or when you get it in non-raw mode. Setting
# values using the mapping protocol or ConfigParser's set() does not allow
# such assignments to take place.
config.add_section('Section1')
config.set('Section1', 'an_int', '15')
config.set('Section1', 'a_bool', 'true')
config.set('Section1', 'a_float', '3.1415')
config.set('Section1', 'baz', 'fun')
config.set('Section1', 'bar', 'Python')
config.set('Section1', 'foo', '%(bar)s is %(baz)s!')

# Writing our configuration file to 'example.cfg'
with open('example.cfg', 'w') as configfile:
    config.write(configfile)
```

读取

``` python
import configparser

config = configparser.RawConfigParser()
config.read('example.cfg')

# getfloat() raises an exception if the value is not a float
# getint() and getboolean() also do this for their respective types
a_float = config.getfloat('Section1', 'a_float')
an_int = config.getint('Section1', 'an_int')
print(a_float + an_int)

# Notice that the next output does not interpolate '%(bar)s' or '%(baz)s'.
# This is because we are using a RawConfigParser().
if config.getboolean('Section1', 'a_bool'):
    print(config.get('Section1', 'foo'))
```

一些附加用法

``` python
import configparser

cfg = configparser.ConfigParser()
cfg.read('example.cfg')

# Set the optional *raw* argument of get() to True if you wish to disable
# interpolation in a single get operation.
print(cfg.get('Section1', 'foo', raw=False)) # -> "Python is fun!"
print(cfg.get('Section1', 'foo', raw=True))  # -> "%(bar)s is %(baz)s!"

# The optional *vars* argument is a dict with members that will take
# precedence in interpolation.
print(cfg.get('Section1', 'foo', vars={'bar': 'Documentation','baz': 'evil'}))

# The optional *fallback* argument can be used to provide a fallback value
print(cfg.get('Section1', 'foo'))
      # -> "Python is fun!"

print(cfg.get('Section1', 'foo', fallback='Monty is not.'))
      # -> "Python is fun!"

print(cfg.get('Section1', 'monster', fallback='No such things as monsters.'))
      # -> "No such things as monsters."

# A bare print(cfg.get('Section1', 'monster')) would raise NoOptionError
# but we can also use:

print(cfg.get('Section1', 'monster', fallback=None))
      # -> None


# New instance with 'bar' and 'baz' defaulting to 'Life' and 'hard' each
config = configparser.ConfigParser({'bar': 'Life', 'baz': 'hard'})
config.read('example.cfg')

print(config.get('Section1', 'foo')) # -> "Python is fun!"
config.remove_option('Section1', 'bar')
config.remove_option('Section1', 'baz')
print(config.get('Section1', 'foo')) # -> "Life is hard!"
```

### ini文件格式

配置文件中遵守以下规则:

- section区分大小写
- parser不区分大小写,并且key和KEY或者Key都代表同一个key,他们必须唯一

``` ini
[DEFAULT]
default_key: every section has me

[simple values]
key = value
space in key = allowed
space in value = allowed
space around the delimiter = obviously yes
you can also use : to delimit keys from values

[all value are stings]
values like this: 10000
or this: 3.1415926
all things is string, so you can use API to get them directly

[multiline values]
chorus: I'm a lumberjack, and I'm okey
    I sleep all night and I work all day

[No values]
key_without_value
empty string value here =

[you can alse use comments]
# like this
; or this
```

### 配置文件中的变量

基础用法: 可以在一个section中使用(默认interpolation是`configparser.BasicInterpolation`):

``` ini
[Paths]
home_dir: /Users
my_dir: %(home_dir)s/lumberjeck
my_pictures: %(home_dir)s/Pictures
```

举个例子, 有如下配置文件:

``` ini
[MyPath]
home_dir: /home
my_home: %(home_dir)s/billx
```

python中读取:

``` python
config = configparser.ConfigParser()
config.read('test_pyconfig.ini')
sections = config.sections()
print(sections)
print(config['MyPath'].get('my_home'))
```

当然,也可以在其他section中引用,不过需要修改默认的interpolation为`configparser.ExtendInterpolation`

``` ini
[Common]
home_dir: /home
library_dir: /Library

[MoreAdvanceUsage]
home_dir: /home
my_home: ${home_dir}/billx
my_library: ${Common:library_dir}/billx
```

使用configparse时需要修改默认的interpolation配置

``` python
config = configparser.ConfigParser(interpolation=configparser.ExtendedInterpolation())
config.read('test_pyconfig.ini')
sections = config.sections()
print(sections)
print(config['MoreAdvanceUsage'].get('my_library'))
```

### Comment与parser冲突问题

说明,value中包含#在行内是okay的,但是如果出现在开头就会被视为comment,所以可以使用`DEFAULTSECT`中定义好#,然后在其他sections中用引号引用即可.

``` python
>>> from configparser import ConfigParser, ExtendedInterpolation
>>> parser = ConfigParser(interpolation=ExtendedInterpolation())
>>> # the default BasicInterpolation could be used as well
>>> parser.read_string("""
... [DEFAULT]
... hash = #
...
... [hashes]
... shebang =
...   ${hash}!/usr/bin/env python
...   ${hash} -*- coding: utf-8 -*-
...
... extensions =
...   enabled_extension
...   another_extension
...   #disabled_by_comment
...   yet_another_extension
...
... interpolation not necessary = if # is not at line start
... even in multiline values = line #1
...   line #2
...   line #3
... """)
>>> print(parser['hashes']['shebang'])

#!/usr/bin/env python
# -*- coding: utf-8 -*-
>>> print(parser['hashes']['extensions'])

enabled_extension
another_extension
yet_another_extension
>>> print(parser['hashes']['interpolation not necessary'])
if # is not at line start
>>> print(parser['hashes']['even in multiline values'])
line #1
line #2
line #3
```

### 自定义boolean

使用`.getboolean`方法可以获取到key对应的boolean值,默认支持

- `True`: '1', 'yes', 'true', 'on'
- `False`: '0', 'no', 'false', 'off'

也可以自己配置`configparser.BOOLEAN_STATES`配置

``` python
>>> custom = configparser.ConfigParser()
>>> custom['section1'] = {'funky': 'nope'}
>>> custom['section1'].getboolean('funky')
Traceback (most recent call last):
...
ValueError: Not a boolean: nope
# 自己定义
>>> custom.BOOLEAN_STATES = {'sure': True, 'nope': False}
>>> custom['section1'].getboolean('funky')
False
```

### value需要大写方案

默认获取到的value是小写的,如果一定需要大写,就需要重写`configparser.optionxform`

``` python
>>> config = """
... [Section1]
... Key = Value
...
... [Section2]
... AnotherKey = Value
... """
>>> typical = configparser.ConfigParser()
>>> typical.read_string(config)
>>> list(typical['Section1'].keys())
['key']
>>> list(typical['Section2'].keys())
['anotherkey']
>>> custom = configparser.RawConfigParser()
>>> custom.optionxform = lambda option: option
>>> custom.read_string(config)
>>> list(custom['Section1'].keys())
['Key']
>>> list(custom['Section2'].keys())
['AnotherKey']
```

## 声明

**版权：** 2018-now，:cn:，zangjiaao\<zangjiaao@yahoo.com>

由家浩创作并维护的`zangjiaao's blog`博客所有文章除特别声明外，均采用"署名-非商业性使用-相同方式共享4.0(CC BY-NC-SA 4.0)[国际许可证](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)"。

本文首发于[zangjiaao's blog](https://blog.zangjiaao.cn/)博客，转载请注明出处。
