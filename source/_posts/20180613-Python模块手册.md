---
title: Python模块手册
categories: '04_学习笔记'
tags:
  - python
date: 2018-06-13 20:38:11
---

**概述：** 主要用于备忘，记录一些我常用到的一些类的Tips和特性(*基于python3)..[官方的ApiDoc](https://docs.python.org/3/library/re.html)..

 <!-- more -->

{% asset_path 20180613-Python模块手册 %}

# Python模块手册

@[TOC]

## TODO

- [ ] 学习`os`模块
- [x] 学习`time`以及`datetime`模块
- [ ] 学习`threading`和`queue`模块
- [ ] 研究`collection`和`heapq`模块
- [ ] 学习`templefile`模块[11.6. tempfile — Generate temporary files and directories &#8212; Python 3.7.0 documentation](https://docs.python.org/3/library/tempfile.html)

## os(系统相关)

os.path参考:

[python os.path模块常用方法详解 - 巫谢 - 博客园](https://www.cnblogs.com/wuxie1989/p/5623435.html)

[5.19 创建临时文件和文件夹 &mdash; python3-cookbook 3.0.0 文档](https://python3-cookbook.readthedocs.io/zh_CN/latest/c05/p19_make_temporary_files_and_directories.html)

## paramiku(SSH控制端)

1. 参考这篇[文章](http://mingxinglai.com/cn/2015/06/paramiko/).
2. 官方API[文档](https://paramiko-docs.readthedocs.io/en/2.4/api/sftp.html).

### 安装

``` bash
sudo pip instal paramiko
```

### 初始化连接

``` python
import paramiko

ssh = paramiko.SSHClient()

#允许连接到不在本机know_hosts中的主机
ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())

# 以密钥对方式建立:
ssh_client.connect("IP",  port, username="username", password="password")

# 以密钥对方式建立:
ssh.connect('IP',port, '用户名', key_filename='/home/xxx/.ssh/id_rsa', passphrase='xxx')
```

可执行单条命令,通过传统std接收输入输出,以及error:

``` python
stdin, stdout, stderr = ssh_client.exec_command('ls -l')
print(stdout.readlines())
```

### 建立channel

``` python
with ssh_client.invoke_shell() as ssh_channel:
    ssh_channel.send('whoami\n')
    buff = ssh_channel.recv(999)


channel = ssh.invoke_shell()
if not recv_ready():
    return('连接未就绪')
channel.send('su - billx' + '\n')
buff = channel.recv(9999)
print(buff)
channel.close()
```

### 最佳实践

#### su方式运行

``` python
import paramiko
import time
import copy
import re

ssh_client = paramiko.SSHClient()
ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
ssh_client.connect('192.168.56.101', username='billx', password='qwe123')

def exec_cmd(cmd):
    with ssh_client.invoke_shell() as chann:
        while not chann.recv_ready():
            time.sleep(1)
            print('delayA..')
        while chann.recv_ready():
            chann.recv(1024)

        su_pwd = 'qwe123'
        chann.send('su - root\n')
        while not chann.recv_ready():
            time.sleep(1)
            print('delayB..')
        chann.send(su_pwd + '\n')
        while not chann.recv_ready():
            time.sleep(1)
            print('delayC..')
        while chann.recv_ready():
            data = chann.recv(1024)

        chann.send(cmd + '\n')
        while not chann.recv_ready():
            time.sleep(1)
            print('delayD..')

        data = b''
        while True:
            if not chann.recv_ready():
                data = filter(lambda x: not re.match('\[.*?][#$]\s+$', x),
                              data.decode().split('\r\n')[1:])
                print('\n'.join(data))
                break
            tmp = chann.recv(1024)
            data += tmp

cmd = 'ss -tulnap'
exec_cmd(cmd)

print('\ndone..\n')

cmd = 'pwd'
exec_cmd(cmd)

```

## logging(日志)

[python logging模块使用教程](https://www.jianshu.com/p/feb86c06c4f4)

### XMind一图搞懂

{% asset_image 2018-08-22-01-47-16.png logging模块xmind %}

[xmind文件](https://pan.baidu.com/s/1OxMi-X26vjhRvoYunJ8PkQ)(密码:bpwr)

### 练习Demo

[billxllid/python_learn](https://github.com/billxllid/python_learn/blob/master/day13_logging.py)

## pymysql(mysql客户端)

### 常规流程

``` python
import pymysql

# 建立连接

conn = pymysql.connect(
  host = 'localhost',
  port = 3306,
  user = 'tester',
  passwd = 'qwe123',
  db = 'test',
  charset = 'utf8'
)

# 创建游标

try:
    cursor = connect.cursor()
except pymysql.MySQLError as e:
    print('Connect error. Detail: %s' % str(e))

# 构建SQL语句

sql = """
SELECT VERSION()
"""

# 执行

try:
    cursor.execute(sql)
except pymysql.ProgrammingError as e:
    print(e)
    exit()

# 获取响应

r = cursor.fetchall()
print(r)

# INSERT、UPDATE需要commit()，否则无法实际修改数据

conn.commit()

# 关闭游标和连接

cursor.close()
conn.close()
```

### with简化连接

免得每次都要`conn.close()`

```
# 使用with简化连接过程，每次都连接关闭很麻烦，使用上下文管理，简化连接过程
import pymysql
import contextlib


# 定义上下文管理器，连接后自动关闭连接
@contextlib.contextmanager
def mysql(host='127.0.0.1', port=3306, user='blog', passwd='123456', db='blog', charset='utf8'):
    conn = pymysql.connect(host=host, port=port, user=user, passwd=passwd, db=db, charset=charset)
    cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)
    try:
        yield cursor
    finally:
        conn.commit()
        cursor.close()
        conn.close()

# 执行sql
with mysql() as cursor:
    # 左连接查询
    r = cursor.execute("select * from users as u left join articles as a on u.id = a.user_id where a.user_id = 2")
    result = cursor.fetchall()
    print(result)
```

### 防SQL注入

- **参数化查询**

内部执行参数化生成的SQL语句，对特殊字符进行了加`\`转义，避免注入语句生成。

``` python
cursor.execute("""
select username,password
from tb7
where username=%s and password=%s""", (username, password))

# 或者将sql语句与data拆分也可以
sql = """
 ...
"""
data = ( .. ,)
cursor.execute(sql, data)
```

在插入多行数据时，使用`executemay`效果要更好。

``` python
cursor.executemany("""
INSERT INTO user(
    username,
    userpass,
    email
)VALUE(%s, %s, %s)
""", [('A', '123', '123@qq.com'), ('B', '456', '456@qq.com')])
```

- **存储过程**

``` python
sql1="select * from users where nid>? and nid<?"
cursor.callproc('proc_sql', args=(11, 15, sql1))
```

更多详见[python中操作mysql的pymysql模块详解](https://www.jianshu.com/p/f11508c98e62)。

### 查询数据获取

``` python
# 获取第一行数据
row_1 = cursor.fetchone()

# 获取前n行数据
row_n = cursor.fetchmany(3)

# 获取所有数据
row_3 = cursor.fetchall()
```

### 获取最新自增ID

``` python
new_id = cursor.lastrowid
```

### 游标操控

``` python
# 相对当前位置移动
cursor.scroll(1,mode='relative')

# 相对绝对位置移动
cursor.scroll(2,mode='absolute')
```

### 错误回滚

``` python
try:
   cursor.execute(sql)
   conn.commit()
except:

   # 如果发生错误则回滚

   conn.rollback()
```

### 调用存储过程

- **无参存储过程**

``` python
#游标设置为字典类型
cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)

#等价于cursor.execute("call p2()")
cursor.callproc('p2')

row_1 = cursor.fetchone()
print(row_1)
```

- **有参存储过程**

``` python
cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)

cursor.callproc('p1', args=(1, 22, 3, 4))

# 获取执行完存储的参数,参数@开头
cursor.execute("select @p1,@_p1_1,@_p1_2,@_p1_3")

# {u'@_p1_1': 22, u'@p1': None, u'@_p1_2': 103, u'@_p1_3': 24}
row_1 = cursor.fetchone()
print(row_1)
```

### 异常处理

请参考[pymysql异常处理](http://www.runoob.com/python3/python3-mysql.html)文末。

## argparse(用户传参控制)

可以用`argparse`替代原来的`getparse`以及`optparse`了。参考:

1. [PEP 389 -- argparse - New Command Line Parsing Module](https://www.python.org/dev/peps/pep-0389/#updates-to-getopt-documentation)
2. [argparse — Parser for command-line options, arguments and sub-commands &#8212; Python 3.7.0 documentation](https://docs.python.org/3/library/argparse.html#argparse.ArgumentParser.add_argument)。

### 创建实例

``` python
# [ ArgumentParser ]
parse = argparse.ArgumentParser(prog='my_prog',
                                usage='这里是用法...',
                                description='这里是程序的描述...',
                                epilog='这是一些exp, "my_prog.py -d A file_path"',  # 会添加到help的末尾
                                prefix_chars='-',  # 顾名思义...
                                formatter_class=argparse.ArgumentDefaultsHelpFormatter,  # help的显示风格, 下面有介绍
                                add_help=False)  # 是否使用默认的help, 如果要自定义help, 可以在这里取消默认

# [ formatter_class ]
# 有以下几种
# argparse.RawDescriptionHelpFormatter  help中支持换行, 默认换行会被过滤. 作用范围为desc和epi.
# argparse.RawTextHelpFormatter  效果同上, 不过作用域是整个help
# argparse.ArgumentDefaultsHelpFormatter  会默认添加(default: XXX)到每一个参数help的结尾, 相对有用.
# argparse.MetavarTypeHelpFormatter  只用参数类型作为每一个参数的help, 感觉不是很好用.
```

### 添加参数

``` python
# [ 添加: add_argument ]
# 不用指定参数, 类似sys.argv[], 比如传入文件路径之类的
parse.add_argument('file')

parse.add_argument('-d', '--demo',
                   nargs=1,  # 传入参数的数量, 那么-d后面跟的两个参数都会被作为参数传入, 是一个list. 还有一些可选, 在下面有描述.
                   action='store',  # 动作, 下面介绍了支持的类型
                   dest='demo',  # 传入参数后, 引用的命名空间. 以后可以使用parse.parse_args().demo来获取传入的参数
                   metavar='HELLO',  # -d HELLO --demo HELLO, 替换HELLO位置描述用的
                   required=True,  # 是否必要
                   type=str,  # 传入数据的数据类型
                   choices=['A', 'B'],  # 数据可选, 只能是'A'或者'B'
                   help='这是demo参数的help')  # 该parse的帮助

# [ 其中nargs还有许多参数 ]
# nargs支持:
# - N: 数字, 指有n个值会传入这个参数中.
# - ?: 0或1个参数会传入参数中, 需要制定const和default, 如果没有参数传入, 则参数为default中的值. 如果参数传入, 则会被替换为const的值.
# - *: 不限制传入的个数, 传入的参数会被作为list看待
# - +: 和*是一样的, 不过不支持0个参数(会返回usage)
#

# [ 其中action还有许多参数 ]
# action支持:
# - store: 默认, 将值存到对应的dest中,
# - store_const: Flag模式, 需要同时制定const, 不用传值, 值为const中给定的值
# - store_true | store_false: Flag模式, 不用制定const, 值为True或者False
# - append: 多值模式, 允许多次传入(类似docker的--env), 传入后组成一个list
# - append_const: 多值模式, 需要同时制定const, 不用传值,传入的值使用const中的对象组成list
# - count: 计数模式, 加入指定-v的话, name-vvv获得的值为3
# - help: 配置帮助, 不过要在创建实例的时候添加"add_help=False", 否则会有冲突用不了
# - version: 需要制定version, 用于显示版本

parse.add_argument('--version',
                   action='version',
                   version='%(prog)s 1.0',
                   help='显示程序当前版本')
parse.add_argument('-h', '--help',
                   action='help',
                   help='这是我自定义的HELP内容')
parse.add_argument('--flag1',  # Flag模式, 不用传值, 使用const中的值. xxx.py -F -> flag=1
                   action='store_const',
                   const=1,
                   help='Flag模式, 值为1',)
parse.add_argument('--flag2',  # Flag模式, 直接保存bool, 还有一个action='store_false'
                   action='store_true',
                   help='Flag模式, 值为True')
parse.add_argument('--verbose', '-v',
                   action='count',
                   help='设置显示等级, 比如-vv就显示更加详细的内容')
```

### 添加参数组

``` python
# [ add_argument_group: 添加一个参数组 ]

group1 = parse.add_argument_group('group_name', 'group_description')
group1.add_argument('-o', '--omg',
                    dest='omg',
                    help='oh my god!')
```

### 使用参数

``` python
# [ parse_args ]
args = parse.parse_args()
print(args)
# 也可以使用下面的方式直接使用:
# args.demo获取到demo这个参数中的值.
# 不过使用vars()函数可以把变量整合变成字典, 方便操作.
args = vars(args)
print(args.items())
```

### 小demo

``` python
import argparse

def get_parser():
    parser = argparse.ArgumentParser(description='scanless, public port scan scrapper')
    parser.add_argument('-v', '--version', help='display the current version',
                        action='store_true')
    parser.add_argument('-t', '--target', help='ip or domain to scan',
                        type=str)
    parser.add_argument('-s', '--scanner', help='scanner to use (default: hackertarget)',
                        type=str, default='hackertarget')
    return parser

def main():
    parser = get_parser()
    args = vars(parser.parse_args())

if __name__ == '__main__':
    main()
```

## configparser(配置文件控制)

参考：[14.2. configparser — Configuration file parser &#8212; Python 3.6.6rc1 documentation](https://docs.python.org/3/library/configparser.html)。

### 展示(推荐)

[billxllid/python_learn](https://github.com/billxllid/python_learn/blob/master/day09_configparser.py)

### 创建

``` python
import configparser
config = configparser.ConfigParser()
# 创建空分类
config['EMPTY'] = {}
# 赋值
config['EMPTY']['test'] = 'test'
# 优雅方式赋值..
x = config['EMPTY']
x['test2'] = 'test2'
# 创建时直接赋值..
config['DEFAULT'] = {
    'test3': 'test3',
    'test4': 'test4',
}
# 修改
config['DEFAULT']['test4'] = 'test5'
# 写入文件
with open('test_pyconfig.ini', 'w') as configfile:
    config.write(configfile)
```

生成如下配置文件:

``` ini
# test_pyconfig.ini
[DEFAULT]
test3 = test3
test4 = test5

[EMPTY]
test = test
test2 = test2
```

### 读取

``` python
import configparser

config = configparser.ConfigParser()
config.read('example.ini')
```

### 传统模式(更高级)

创建

``` python
import configparser

config = configparser.RawConfigParser()

# Please note that using RawConfigParser's set functions, you can assign
# non-string values to keys internally, but will receive an error when
# attempting to write to a file or when you get it in non-raw mode. Setting
# values using the mapping protocol or ConfigParser's set() does not allow
# such assignments to take place.
config.add_section('Section1')
config.set('Section1', 'an_int', '15')
config.set('Section1', 'a_bool', 'true')
config.set('Section1', 'a_float', '3.1415')
config.set('Section1', 'baz', 'fun')
config.set('Section1', 'bar', 'Python')
config.set('Section1', 'foo', '%(bar)s is %(baz)s!')

# Writing our configuration file to 'example.cfg'
with open('example.cfg', 'w') as configfile:
    config.write(configfile)
```

读取

``` python
import configparser

config = configparser.RawConfigParser()
config.read('example.cfg')

# getfloat() raises an exception if the value is not a float
# getint() and getboolean() also do this for their respective types
a_float = config.getfloat('Section1', 'a_float')
an_int = config.getint('Section1', 'an_int')
print(a_float + an_int)

# Notice that the next output does not interpolate '%(bar)s' or '%(baz)s'.
# This is because we are using a RawConfigParser().
if config.getboolean('Section1', 'a_bool'):
    print(config.get('Section1', 'foo'))
```

一些附加用法

``` python
import configparser

cfg = configparser.ConfigParser()
cfg.read('example.cfg')

# Set the optional *raw* argument of get() to True if you wish to disable
# interpolation in a single get operation.
print(cfg.get('Section1', 'foo', raw=False)) # -> "Python is fun!"
print(cfg.get('Section1', 'foo', raw=True))  # -> "%(bar)s is %(baz)s!"

# The optional *vars* argument is a dict with members that will take
# precedence in interpolation.
print(cfg.get('Section1', 'foo', vars={'bar': 'Documentation','baz': 'evil'}))

# The optional *fallback* argument can be used to provide a fallback value
print(cfg.get('Section1', 'foo'))
      # -> "Python is fun!"

print(cfg.get('Section1', 'foo', fallback='Monty is not.'))
      # -> "Python is fun!"

print(cfg.get('Section1', 'monster', fallback='No such things as monsters.'))
      # -> "No such things as monsters."

# A bare print(cfg.get('Section1', 'monster')) would raise NoOptionError
# but we can also use:

print(cfg.get('Section1', 'monster', fallback=None))
      # -> None


# New instance with 'bar' and 'baz' defaulting to 'Life' and 'hard' each
config = configparser.ConfigParser({'bar': 'Life', 'baz': 'hard'})
config.read('example.cfg')

print(config.get('Section1', 'foo')) # -> "Python is fun!"
config.remove_option('Section1', 'bar')
config.remove_option('Section1', 'baz')
print(config.get('Section1', 'foo')) # -> "Life is hard!"
```

### ini文件格式

配置文件中遵守以下规则:

- section区分大小写
- parser不区分大小写,并且key和KEY或者Key都代表同一个key,他们必须唯一

``` ini
[DEFAULT]
default_key: every section has me

[simple values]
key = value
space in key = allowed
space in value = allowed
space around the delimiter = obviously yes
you can also use : to delimit keys from values

[all value are stings]
values like this: 10000
or this: 3.1415926
all things is string, so you can use API to get them directly

[multiline values]
chorus: I'm a lumberjack, and I'm okey
    I sleep all night and I work all day

[No values]
key_without_value
empty string value here =

[you can alse use comments]
# like this
; or this
```

### 配置文件中的变量

基础用法: 可以在一个section中使用(默认interpolation是`configparser.BasicInterpolation`):

``` ini
[Paths]
home_dir: /Users
my_dir: %(home_dir)s/lumberjeck
my_pictures: %(home_dir)s/Pictures
```

举个例子, 有如下配置文件:

``` ini
[MyPath]
home_dir: /home
my_home: %(home_dir)s/billx
```

python中读取:

``` python
config = configparser.ConfigParser()
config.read('test_pyconfig.ini')
sections = config.sections()
print(sections)
print(config['MyPath'].get('my_home'))
```

当然,也可以在其他section中引用,不过需要修改默认的interpolation为`configparser.ExtendInterpolation`

``` ini
[Common]
home_dir: /home
library_dir: /Library

[MoreAdvanceUsage]
home_dir: /home
my_home: ${home_dir}/billx
my_library: ${Common:library_dir}/billx
```

使用configparse时需要修改默认的interpolation配置

``` python
config = configparser.ConfigParser(interpolation=configparser.ExtendedInterpolation())
config.read('test_pyconfig.ini')
sections = config.sections()
print(sections)
print(config['MoreAdvanceUsage'].get('my_library'))
```

### Comment与parser冲突问题

说明,value中包含#在行内是okay的,但是如果出现在开头就会被视为comment,所以可以使用`DEFAULTSECT`中定义好#,然后在其他sections中用引号引用即可.

``` python
>>> from configparser import ConfigParser, ExtendedInterpolation
>>> parser = ConfigParser(interpolation=ExtendedInterpolation())
>>> # the default BasicInterpolation could be used as well
>>> parser.read_string("""
... [DEFAULT]
... hash = #
...
... [hashes]
... shebang =
...   ${hash}!/usr/bin/env python
...   ${hash} -*- coding: utf-8 -*-
...
... extensions =
...   enabled_extension
...   another_extension
...   #disabled_by_comment
...   yet_another_extension
...
... interpolation not necessary = if # is not at line start
... even in multiline values = line #1
...   line #2
...   line #3
... """)
>>> print(parser['hashes']['shebang'])

#!/usr/bin/env python
# -*- coding: utf-8 -*-
>>> print(parser['hashes']['extensions'])

enabled_extension
another_extension
yet_another_extension
>>> print(parser['hashes']['interpolation not necessary'])
if # is not at line start
>>> print(parser['hashes']['even in multiline values'])
line #1
line #2
line #3
```

### 自定义boolean

使用`.getboolean`方法可以获取到key对应的boolean值,默认支持

- `True`: '1', 'yes', 'true', 'on'
- `False`: '0', 'no', 'false', 'off'

也可以自己配置`configparser.BOOLEAN_STATES`配置

``` python
>>> custom = configparser.ConfigParser()
>>> custom['section1'] = {'funky': 'nope'}
>>> custom['section1'].getboolean('funky')
Traceback (most recent call last):
...
ValueError: Not a boolean: nope
# 自己定义
>>> custom.BOOLEAN_STATES = {'sure': True, 'nope': False}
>>> custom['section1'].getboolean('funky')
False
```

### value需要大写方案

默认获取到的value是小写的,如果一定需要大写,就需要重写`configparser.optionxform`

``` python
>>> config = """
... [Section1]
... Key = Value
...
... [Section2]
... AnotherKey = Value
... """
>>> typical = configparser.ConfigParser()
>>> typical.read_string(config)
>>> list(typical['Section1'].keys())
['key']
>>> list(typical['Section2'].keys())
['anotherkey']
>>> custom = configparser.RawConfigParser()
>>> custom.optionxform = lambda option: option
>>> custom.read_string(config)
>>> list(custom['Section1'].keys())
['Key']
>>> list(custom['Section2'].keys())
['AnotherKey']
```

## re(正则匹配)

参考[官方API文档](https://docs.python.org/3/library/re.html).

### re.compile_编译

- **语法**

``` python
re.compile(pattern, flags=0)
```

- **说明**

会先把正则表达式进行编译, `pattern`为正则表达式, `flages`能够操控匹配的模式.

例如:

``` python
prog = re.compile(pattern)
result = prog.match(string)
```

相当于:

``` python
result = re.match(pattern, string)
```

常用flages:

1. `re.I`或`re.IGNORECASE`: 不区分大小写. 连[A-Z]也同时可以匹配小写字母.
2. `re.M`或`re.MULTILINE`: `^`和`$`可以覆盖到多行.
3. `re.S`或`re.DOTALL`: `.`可以匹配包括换行符在内的的所有内容.
4. `re.X`或`re.VERBOSE`: 允许使用更加易读的方式书写表达式.`空白字符`会被忽略, 同时还可以进行注释, 见例子1.

- **例子1**

``` python
a = re.compile(r"""\d +  # the integral part
                   \.    # the decimal point
                   \d *  # some fractional digits""", re.X)
b = re.compile(r"\d+\.\d*")
```

## PyYAML

基本用法请参考:[官方文档](https://pyyaml.org/wiki/PyYAMLDocumentation).

这里主要列出一些技巧.

### 输出的style

列出dump能够使用的参数:

- default_style=None,
- default_flow_style=None,  # (bool)flow风格开关
- canonical=None,  # (bool)是否显示数据类型标签
- indent=None,  # (int)缩进
- width=None,  # (int)宽度
- allow_unicode=None,  # (bool)是否允许unicode编码
- line_break=None,  # 指定换行的特殊字符
- encoding=None, # 编码类型
- explicit_start=None,  # suffix
- explicit_end=None,  # preffix
- version=None,
- tags=None

默认情况下, dump出来的yaml数据使用的是流式(flow)风格, 也那就是下面的情况:

``` python
print(yaml.dump([i for i in range(5)]))
# out:
[0, 1, 2, 3, 4]
```

可通过改变参数实现块式(block)风格输出, 更经典.

``` python
print(yaml.dump([i for i in range(5)], default_flow_style=False))
# out:
- 0
- 1
- 2
- 3
- 4
```

带数据格式tag的输出

``` python
print(yaml.dump([i for i in range(5)], canonical=True))
# out:
---
!!seq [
  !!int "0",
  !!int "1",
  !!int "2",
  !!int "3",
  !!int "4",
]
```

### Yaml特殊格式

多合一

``` python
>>> dat = """
... ---
... - Ada
... - APL
... - ASP
...
... - Assembly
... - Awk
... ---
... - Basic
... ---
... - C
... - C#    # 如果需要使用注释, 使用'C #'而不是'C#'.
... - C++
... - Cold Fusion
... """
# 使用load_all不能直接输出, 需要遍历
>>> yaml.load_all(dat)
<generator object load_all at 0x104a44fc0>
>>> for data in yaml.load_all(dat):
...     print(data)
...
['Ada', 'APL', 'ASP', 'Assembly', 'Awk']
['Basic']
['C', 'C#', 'C++', 'Cold Fusion']
```

list列表的嵌套

``` yaml
# YAML
-
  - HTML
  - LaTeX
  - SGML
  - VRML
  - XML
  - YAML
-
  - BSD
  - GNU Hurd
  - Linux

# Python
[['HTML', 'LaTeX', 'SGML', 'VRML', 'XML', 'YAML'], ['BSD', 'GNU Hurd', 'Linux']]
```

嵌套之前使用'-'或' '不重要, 重要的是要保持缩进

``` yaml
# YAML
- 1.1
- - 2.1
  - 2.2
- - - 3.1
    - 3.2
    - 3.3
# Python
[1.1, [2.1, 2.2], [[3.1, 3.2, 3.3]]]
```

字典与列表的嵌套

``` yaml
# YAML
left hand:
- Ring of Teleportation
- Ring of Speed

right hand:
- Ring of Resist Fire
- Ring of Resist Cold
- Ring of Resist Poison
# Python
{'right hand': ['Ring of Resist Fire', 'Ring of Resist Cold', 'Ring of Resist Poison'],
'left hand': ['Ring of Teleportation', 'Ring of Speed']}
```

列表中嵌套字典

``` yaml
# YAML
- name: PyYAML
  status: 4
  license: MIT
  language: Python
- name: PySyck
  status: 5
  license: BSD
  language: Python
# Python
[{'status': 4, 'language': 'Python', 'name': 'PyYAML', 'license': 'MIT'},
{'status': 5, 'license': 'BSD', 'name': 'PySyck', 'language': 'Python'}]
```

允许key中包含' ', 并且可是使用'?'和':'分两行显示key:value

``` yaml
# YAML
base armor class: 0
# Python
{'base armor class': 0}

# YAML
? key
: value
# Python
{'key': 'value'}
```

5种value的表示方法, 分别是plain, single-quoted, double-quoted, literal, 以及 folded:

```
# YAML
plain: Scroll of Remove Curse
single-quoted: 'EASY_KNOW'
double-quoted: "?"
literal: |    # Borrowed from http://www.kersbergen.com/flump/religion.html
  by hjw              ___
     __              /.-.\
    /  )_____________\\  Y
   /_ /=== == === === =\ _\_
  ( /)=== == === === == Y   \
   `-------------------(  o  )
                        \___/
folded: >
  It removes all ordinary curses from all equipped items.
  Heavy or permanent curses are unaffected.
```

别名,其实感觉就是yaml中的变量

```
# YAML
Host:
      - &foo bar
      - *foo
      - *foo

# Python
{'Host': ['bar', 'bar', 'bar']}


# YAML
left hand: &A
  name: The Bastard Sword of Eowyn
  weight: 30
right hand: *A

# Python
{
    "left hand": {
        "name": "The Bastard Sword of Eowyn",
        "weight": 30
    },
    "right hand": {
        "name": "The Bastard Sword of Eowyn",
        "weight": 30
    }
}
```

标签tag, 更多可见[yaml标签表](http://yaml.org/type/index.html)

```
# YAML
boolean: !!bool "true"
integer: !!int "3"
float: !!float "3.14"

# Python
{'boolean': True, 'integer': 3, 'float': 3.14}

# 可通过修改标签改变数据格式
boolean: !!str "true"
integer: !!int "3"
float: !!float "3.14"

# Python
{
    "boolean": "true",
    "integer": 3,
    "float": 3.14
}
```

yaml下的tag与python数据类型对比表如下:

{% asset_img 2018-08-23-02-03-18.png yaml标签对照表 %}

## time(操作时间数据)

### XMind 一图读懂

{% asset_image 2018-08-29-01-37-03.png python_time库xmind %}

[下载链接](https://pan.baidu.com/s/19nUqk4x8-0XD3NK-9YbuTQ)(密码:cd8c)

## 声明

**版权：** 2018-now，:cn:，zangjiaao\<zangjiaao@yahoo.com>

由家浩创作并维护的`zangjiaao's blog`博客所有文章除特别声明外，均采用"署名-非商业性使用-相同方式共享4.0(CC BY-NC-SA 4.0)[国际许可证](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)"。

本文首发于[zangjiaao's blog](https://blog.zangjiaao.cn/)博客，转载请注明出处。
