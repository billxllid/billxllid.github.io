---
title: SQL语法速查
categories: '04_学习笔记'
tags:
  - SQL
  - 速查
date: 2018-06-14 02:49:04
updated: 2018-07-22 00:04:02
---

**概述：** 在使用python控制mysql(mariadb)的时候不懂SQL真是急死人:cold_sweat:..学习一下SQL语法，填一下以前的坑..主要参考《MySQL必知必会》这本教材，写的不错安利一下~

 <!-- more -->

{% asset_path 20180614-SQL语法速查 %}

# SQL语法速查

@[TOC]

## 语法约定

语法遵循在MySQL中`help`中的结果, 使用以下格式描述.

- `{A|B}`表示"A"或者"B"必须有一个;
- `[A | B]`表示"A"或者"B"或者没有;
- `[A]`表示"A"或者没有;
- `A[ B]`表示"A"或者"A B".
- `(A,)`表示括号包裹的数据, 没有特殊含义.

例如:

``` sql
SHOW [FULL] COLUMNS
{FROM | IN} tbl_name
[{FROM | IN} db_name]
[LIKE 'pattern' | WHERE expr]
```

每个项目的说明格式为:

- **语法**: 顾名思义.
- **说明**: 对于语法中一些关键字的说明.
- **例子**: (可选)一些常用的例子, 各个例子可以使用`或`来分割.
- **补充**: (可选)一些特殊情况的说明.

## 增

### 创建数据库_CREATE_DATABASE

- **语法**:

``` sql
CREATE {DATABASE | SCHEMA} [IF NOT EXISTS] db_name
    [create_specification] ...

create_specification:
    [DEFAULT] CHARACTER SET [=] charset_name
  | [DEFAULT] COLLATE [=] collation_name
```

- **说明**:

`IF NOT EXISTS`: 表示在创建数据库之前, 先判断数据库是否存在, 存在就不创建.

`create_specification`: 创建时的一些定义, 可以在创建数据库之前配置数据库的编码格式, Mariadb默认使用`latin1`, 中文支持不太好, 可以改为`utf8`, 更多支持可见[Supported Character Sets and Collations](https://mariadb.com/kb/en/library/supported-character-sets-and-collations/).

- **例子**:

``` sql
CREATE DATABASE tmp;
```

或:

``` sql
CREATE DATABASE tmp
  CHARACTER SET = 'utf8'
  COLLATE = 'utf8_general_ci';
```

- **补充**:

**场景**: 创建数据库后, 发现数据库编码格式不对, 导致中文字符乱码.
**解决方案**: 需要修改数据库的字符编码.

首先, 查看当前数据库编码(MariaDB下):

``` sql
SELECT * FROM INFORMATION_SCHEMA.SCHEMATA;
```

然后, 修改对应数据库的编码:

``` sql
ALTER DATABASE dbname
  CHARACTER SET = 'utf8'
  COLLATE = 'utf8_general_ci';
```

了解更多, 可查看[Setting Character Sets and Collations](https://mariadb.com/kb/en/library/setting-character-sets-and-collations/).

### 创建表_CREATE_TABLE

- **语法**:

``` sql
CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name
  (create_definition,...)
  [table_options]
  [partition_options]

Or:

CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name
  [(create_definition,...)]
  [table_options]
  [partition_options]
  select_statement

Or:

CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name
  { LIKE old_tbl_name | (LIKE old_tbl_name) }
```

- **说明**:

`TEMPORARY`: 创建零时表, 尝试创建表后, 查询发现并不存在, 不常用.

`create_definition`: 表中各字段的定义, 格式为:

``` sql
col_name data_type column_definition

# 例如
id INT(5) NOT NULL AUTO_INCREMENT PRIMARY KEY
```

常用的几个`column_definition`:

1. `[PRIMARY ]KEY`: 设置主键, `PRIMARY`可以不写, 一个表只能有一个主键;
2. `[NOT NULL| NULL]`: 设置为非空或者为空;
3. `AUTO_INCREMENT`: 设置是否自增, 可;
4. `DEFAULT default_value`: 设置创建时默认的内容;

常用的几个`data_type`, 更多可以看[官方文档](https://mariadb.com/kb/en/library/data-types/):

1. `INT|INTEGER[(length)]`: 整数, 俩一个意思;
2. `CHAR[(length)] [CHARACTER SET charset_name] [COLLATE collation_name]`: 字符串, 同时可以设置字符编码;
3. `VARCHAR(length) [CHARACTER SET charset_name] [COLLATE collation_name]`: 可变长字符串, 同样可以设置字符编码;
4. `BINARY[(length)]`: 二进制;
5. `VARBINARY(length)`: 可变长二进制;
6. `DATE|TIME|TIMESTAMP|DATETIME|YEAR`: 时间格式, 但是只有`TIMESTAMP`可以自动在插入数据或者更新时自动更新, 其他的格式都是起到限制输入的作用, 可以参考[补充1].
7. `TEXT|`:
8. `BOOL`: 布尔值, 其实就是`TINIYINT(1)`, 非0的数都会为`true`

`table_options`: 表的一些选项, 可以在这里指定`ENGINE`之类的, 具体可以键入`help CREATE TABLE`查询.

- **例子**:

``` sql
CREATE TABLE user(
  id INT(5) NOT NULL AUTO_INCREMENT,
  username VARCHAR(20) NOT NULL,
  userpass VARCHAR(20) NOT NULL,
  email VARCHAR(50),
  PRIMARY KEY (id)
)
```

:warning: **注意1**: 只允许有一个自动列, 例如`AUTO_INCREMENT`, 并且其必须被定义为主键, 例如`PRIMARY KEY (id)`.

或:

``` sql
CREATE TABLE IF NOT EXISTS tbl_name(
  id INT NOT NULL AUTO_INCREMENT KEY,
  age INT(2) DEFAULT 18,
  name CHAR(50) NOT NULL
) ENGINE = InnoDB, CHARACTER SET = utf8;
```

- **补充1**:

以下为了方便回忆, 具体可以看[官方文档](https://mariadb.com/kb/en/library/data-types/).

1. `DATE`: YYYY-MM-DD, 分隔符可以是任意符号, 但是最终都会被转换为默认格式.
2. `TIME`: HH:MM:SS.ssssss, 最后的时间戳最多6位, 不指定也可以.
3. `DATETIME`: YYYY-MM-DD HH:MM:SS
4. `TIMESTAMP`: 同上, 但是是自动生成自动更新
5. `YEAR`: 限制了四位数字

## 删

### 删除数据库_DROP_DATABASE

- **语法**:

``` sql
DROP DATABASE `db_name`;
```

### 删除表_DROP_TABLE

- **语法**:

``` sql
DROP TABLE `table_name`;
```

### 删除条目_DELETE

- **语法**:

``` sql
DELETE FROM user
WHERE username=%s
```

## 改

### 修改数据_UPDATE

- **语法**:

``` sql
# 单表修改语法:

UPDATE [LOW_PRIORITY] [IGNORE] table_reference
    SET col_name1={expr1|DEFAULT} [, col_name2={expr2|DEFAULT}] ...
    [WHERE where_condition]
    [ORDER BY ...]
    [LIMIT row_count]

# 多表修改语法:

UPDATE [LOW_PRIORITY] [IGNORE] table_references
    SET col_name1={expr1|DEFAULT} [, col_name2={expr2|DEFAULT}] ...
    [WHERE where_condition]
```

支持同时修改多个表, 但修改多个表时无法使用`ORDER BY`以及`LIMIT`关键字.

- **说明**:



- **例子**:

``` sql
UPDATE user
SET username=%s
WHERE username=%s
```

注意这里的顺序，前面才是更新的内容

### 插入数据_INSERT_INTO

- **语法**:

``` sql
INSERT INTO test(
  username,
  userpass,
  email
)VALUE(%s, %s, %s)
```

## 查

### 表中列信息_SHOW_COLUMNS

- **语法**:

``` sql
SHOW [FULL] COLUMNS
{FROM | IN} tbl_name
[{FROM | IN} db_name] [LIKE 'pattern' | WHERE expr]
```

- **例子**:

``` sql
SHOW COLUMNS
FROM tmp;
```

或:

``` sql
# 显示更多信息
SHOW FULL COLUMNS
FROM tmp;
```

或:

``` sql
SHOW COLUMNS
FROM test.tmp;
```

或:

``` sql
SHOW COLUMNS
FROM tmp
FROM db_name
```

### 限制_LIMIT

- **语法1**:

``` sql
SELECT `col_name`
FROM `tbl_name`
LIMIT 1, 10
```

表示`LIMIT 从第几行开始，输出的最大行数`, 单个代表`LIMIT 输出的最大行数`。

:warning:**注意**: "从第几行开始"的索引号是从0开始的, 而不是1, 因此`LIMIT 1, 1`实际查询的第二行, `LIMIT 0, 1`才是从第一行开始. 见"例子1".

- **语法2**:

从MySQL5开始支持`OFFSET`, 代替"从第几行开始", 语法如下:

``` sql
SELECT `col_name`
FROM `tbl_name`
LIMIT 10 OFFSET 1
```

这里所输出的结果与"语法1"一致.

- **例子1**:

tmp表中有以下数据:

``` text
MariaDB [test]> SELECT * FROM tmp;
+----+------+
| id | name |
+----+------+
|  1 | A    |
|  2 | B    |
|  3 | C    |
|  4 | D    |
+----+------+
```

使用`LIMIT 1, 1`限制查询, 输出了第二行.

``` text
MariaDB [test]> SELECT * FROM tmp LIMIT 1, 1;
+----+------+
| id | name |
+----+------+
|  2 | B    |
+----+------+
```

使用`LIMIT 0, 1`查询, 才输出第一行.

``` text
MariaDB [test]> SELECT * FROM tmp LIMIT 0, 1;
+----+------+
| id | name |
+----+------+
|  1 | A    |
+----+------+
```

### 去重_DISTINCT

- **语法**:

``` sql
SELECT DISTINCT `column_name1`, `column_name2`
FROM `table_name`;
```

:warning:注意: 如果指定多列, 只有指定的所有列都相同才会被过滤掉, 见本节[说明2].

- **说明1**:

以下演示单列查询. 有以下数据:

``` text
MariaDB [test]> select * from distinct_test;
+---------+
| vend_id |
+---------+
| 1001    |
| 1001    |
| 1002    |
| 1003    |
| 1004    |
| 1004    |
| 1004    |
| 1005    |
+---------+
8 rows in set (0.001 sec)
```

希望某列不重复出现:

``` text
MariaDB [test]> select distinct vend_id from distinct_test;
+---------+
| vend_id |
+---------+
| 1001    |
| 1002    |
| 1003    |
| 1004    |
| 1005    |
+---------+
5 rows in set (0.001 sec)
```

- **说明2**:

演示多列查询. 有以下数据:

``` text
MariaDB [test]> select * from tmp;
+---------+------+
| vend_id | name |
+---------+------+
| 1001    | A    |
| 1001    | B    |
| 1001    | C    |
| 1002    | C    |
| 1002    | C    |
+---------+------+
```

其中只有最后两行是完全相同的, 当使用`DISTINCT`过滤时, 只会过滤这两行.

``` text
MariaDB [test]> select distinct vend_id, name from tmp;
+---------+------+
| vend_id | name |
+---------+------+
| 1001    | A    |
| 1001    | B    |
| 1001    | C    |
| 1002    | C    |
+---------+------+
```

### 排序_ORDER_BY

- **语法**:

``` sql
SELECT *
FROM 'tbl_name'
ORDER BY 'col_name1' DESC, 'col_name2' ASC,
```

`col_name*`可以是多个, 指定多个"col_name"会多行排序. 按多个列排序, 会有限排序"col_name1", 然后再将结果按照"col_name2"来排序.

`ASC|DESC`表示**升序**和**降序**. 如果不指定, 那么默认是升序.

### 过滤_WHERE

- **语法1**: 基本过滤

``` sql
SELECT 'select_expr'
FROM 'tbl_name'
WHERE id = 1;
```

或者:

``` sql
WHERE id BETWEEN 1 AND 10;
```

或者:

``` sql
# 和上一条BETWEEN功能相仿.
WHERE id IN (1, 10);
```

或者:

``` sql
WHERE name IS NULL;
```

`BETWEEN`是查找范围内的数据, 使用`AND`分割条件.

`IS NULL`是查找空值的.

支持的条件操作符:

{% asset_img 2018-07-22-02-25-04.png %}

- **语法2**: 组合过滤

支持使用`AND | OR`来组合WHERE查询语句.

``` sql
SELECT 'select_expr'
FROM 'tbl_name'
WHERE ('col_name1' = 1 OR 'col_name1' = 2) AND 'col_name2' > 10
```

这里SQL会优先判断AND, 但是用`()`包裹的会最优先判断.

## 迁移

### 查找数据

``` sql
SELECT username
FROM user
WHERE username != 'test01'
# 按照email排序，然后再用userpass排序，DECS表示倒序
ORDER BY email, userpass DESC

# 只显示从第0行开始，的10行（不是第10行）
# LIMIT只能在末尾
LIMIT 0, 10
```

``` sql
WHERE username = 'test02'
OR email = 'test02@qq.com'
AND userpass = 'qwe123'
```

``` sql
WHERE username BETWEEN 1 AND 10

# 可能只针对数字类型
WHERE username NOT IN (1, 10)
```

``` sql
WHERE username

# 只匹配一个字符
LIKE '_00'

# 类似于'.00.'
LIKE '%00%'
```

### 通配符搜索

``` sql
WHERE username
REGEXP '.0.'

# 非1|2|3
REGEXP '[^123]'

# 转义
REGEXP '\\.'
```

- **匹配元字符**

{% asset_img REGEXP02.png 匹配元字符 %}

- **匹配字符类**

{% asset_img REGEXP01.png 匹配字符类 %}

- **重复元字符**

{% asset_img REGEXP03.png 重复元字符 %}

- **定位元字符**

{% asset_img REGEXP04.png 定位元字符 %}

### 函数

- `Content()`

在mysq中用来拼接字段，其他数据库多数使用`+`或者`||`：

``` sql
SELECT Concat(username, userpass)
FROM user
WHERE username = '500'

输出：
+----------------------------+
| Concat(username, userpass) |
+----------------------------+
| 500qwe123                  |
+----------------------------+

# 当然也可以像字符串一样操作
SELECT Concat(username, '\(', userpass, '\)')
FROM user
WHERE username = '500';
```

- `RTrim()`和`LTrim()`以及`Trim()`

用于去掉左边或者右边的，或者同时两边的`空格`。



## 声明

**版权：** 2018-now，:cn:，zangjiaao\<zangjiaao@yahoo.com>

由家浩创作并维护的`zangjiaao's blog`博客所有文章除特别声明外，均采用"署名-非商业性使用-相同方式共享4.0(CC BY-NC-SA 4.0)[国际许可证](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)"。

本文首发于[zangjiaao's blog](https://blog.zangjiaao.cn/)博客，转载请注明出处。
