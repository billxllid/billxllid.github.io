<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Git学习笔记]]></title>
    <url>%2F2018%2F08%2F28%2FGit%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[概述： 顾名思义, Git笔记! 推荐下官方教材Pro Git book在线版(支持中文哦~). Git学习笔记TODO特别推荐:XMind便于记忆gitignore用法分支的新建与合并删除远程分支声明 TODO待整理 特别推荐:XMind下载链接(密码:s59c) 便于记忆12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# 查看branchgit branch# 查看远端branchgit branch -r# 创建brachgit branch xxx# 切换branchgit checkout xxx# 切换时创建branchgit checkout -b xxx# 删除本地branchgit branch -d xxx# 强制删除(branch修改后没有merge)git branch -D xxx# 删除远端branchgit branch -r -d origin/xxxgit push origin :xxxorgit push origin --delete xxx# 创建本地gitgit init# 添加git remote源git remote add origin git:xxx# 添加git remote源, 同时fetchgit remote add origin -f git:xxx# 修改git remote的namegit remote rename origin xxx# 操作回滚git log xxx # 查看修改, 获取commit idgit reset --hard xxxxxx # 回归到上一次提交# 子模块管理(将子模块绑定到xxx目录下, 会自动生成一个.gitmoudle)git submodule add git@xxx xxx# 子模块初始化(clone下来但是没有加--res)cd xxxgit submodule initgit submodule update# 子模块管理, 更新全部子模块(递归更新)git submodule update --init --recursive# 在clone时就递归更新所有子模块git clone git@xxx --recursiveor # 没试过, 应该一样git clone ggit@xxx --recurse-submodulesgeeeeeeeeek/git-recipes--soft: 缓存区和工作目录都不会被改变--mixed: 默认选项。缓存区和你指定的提交同步，但工作目录不受影响--hard: 缓存区和工作目录都同步到你指定的提交 gitignore用法github/gitignore由于git是不能提交空目录的, 如果需要保留目录, 就需要在要保留的目录下创建一个.gitkeep文件, 可以为空. 使用.ignore也可以. 分支的新建与合并from: Git - 分支的新建与合并 删除远程分支from: git怎么删除远程分支 - SegmentFault 思否删除远程分支和tag在Git v1.7.0 之后，可以使用这种语法删除远程分支：1git push origin --delete &lt;branchName&gt;删除tag这么用：1git push origin --delete tag &lt;tagname&gt;否则，可以使用这种语法，推送一个空分支到远程分支，其实就相当于删除远程分支：1git push origin :&lt;branchName&gt;这是删除tag的方法，推送一个空tag到远程tag：12git tag -d &lt;tagname&gt;git push origin :refs/tags/&lt;tagname&gt;两种语法作用完全相同。删除不存在对应远程分支的本地分支假设这样一种情况：我创建了本地分支b1并pull到远程分支 origin/b1；其他人在本地使用fetch或pull创建了本地的b1分支；我删除了 origin/b1 远程分支；其他人再次执行fetch或者pull并不会删除这个他们本地的 b1 分支，运行 git branch -a 也不能看出这个branch被删除了，如何处理？使用下面的代码查看b1的状态：123456789101112$ git remote show origin* remote origin Fetch URL: git@github.com:xxx/xxx.git Push URL: git@github.com:xxx/xxx.git HEAD branch: master Remote branches: master tracked refs/remotes/origin/b1 stale (use &apos;git remote prune&apos; to remove) Local branch configured for &apos;git pull&apos;: master merges with remote master Local ref configured for &apos;git push&apos;: master pushes to master (up to date)这时候能够看到b1是stale的，使用 git remote prune origin 可以将其从本地版本库中去除。更简单的方法是使用这个命令，它在fetch之后删除掉没有与远程分支对应的本地分支：git fetch -p 声明版权： 2018-now，🇨🇳，zangjiaao&lt;zangjiaao@yahoo.com&gt;由家浩创作并维护的zangjiaao's blog博客所有文章除特别声明外，均采用&quot;署名-非商业性使用-相同方式共享4.0(CC BY-NC-SA 4.0)国际许可证&quot;。本文首发于zangjiaao’s blog博客，转载请注明出处。]]></content>
      <categories>
        <category>04_学习笔记</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ansible笔记]]></title>
    <url>%2F2018%2F07%2F05%2FAnsible%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[概述： ansible基于python实现，是一款强大的多主机管理工具。通过他可以实现批量的任务执行，大大简化了大量主机场景下的维护难度。 Ansible笔记参考自国内最专业的Ansible中文官方学习手册。TODO指令用法主机对象(host-pattern)选项(options)模块(modle)Inventory文件基本分组/合并变量参数说明加密playbook脚本demo声明 TODO一些有趣的用法:Ansible 小手册系列 二十（经常遇到的问题）.补全模块中的内容:补全playbook中的内容:Introduction To Ad-Hoc Commands — 国内最专业的Ansible中文官方学习手册 指令用法典型指令:1234ansible &lt;host-pattern&gt; [options]# example:ansible example -m service -a "name=httpd state=restarted" 主机对象(host-pattern)改变host-pattern则可以改变要操作的主机对象,有一定的语法格式:123456789101112131415161718192021222324252627# 所有主机all*# 单个IP或者分组127.0.0.1dns.example.comgruop01# 多个IP(支持通配符)192.168.1.*# 多个主机或者判定条件,使用:分割127.0.0.1:127.0.0.2foo.example.com:foo.excample.com# 条件范围(可以多个同时作为条件)group01:!group02 # 从group01中排除group02中的组员host:!centosgroup01:!group02 # group01与02共同的主机(交集)# 组中某几个主机group01[2]group01[1-5]# 正则表达式(~开头即可,有点像awk的if判断)~(web|db).*\.example\.com--limit有助于排除一部分条目(黑名单)1234ansible-playbook site.yml --limit datacenter2# 如果你想从文件读取hosts,文件名以@为前缀即可.从Ansible 1.2开始支持该功能:ansible-playbook site.yml --limit @retry_hosts.txt 选项(options)比较常用到的:命令:-i INVENTORY: 指定inventory文件-m MODULE_NAME: 指定模块(下面会说明,默认是command)-a MODULE_ARGS: 模块属性-f FORKS, --forks=FORKS: 设置并发线程,默认5个输出:-o: 一行输出,将结果格式化为一行输出-v: verbose,-vvv可现实更多,-vvvv开启debug模式用户:-k, --ask-pass: 交互式输入-u USER指定user的密码--private-key=PRIVATE_KEY_FILE: 私钥方式登录-u REMOTE_USER: 指定登录的用户权限:a) sudo方式-s, --sudo: *建议使用become,sudo方式运行指令-U SUDO_USER: 指定对应的sudo用户身份,默认root--sudo-user=SUDO_USER--ask-sudo-pass: 输入sudo的密码例子:12345678ansible 192.168.56.101 \-m shell -a 'whoami &amp;&amp; pwd' \-u billx -k \-s -U root --ask-sudo-pass输出:192.168.56.101 | SUCCESS | rc=0 &gt;&gt;rootb) su方式-S, --su: *建议使用become,su切换用户-R SU_USER: 指定对应的su切换的用户身份--su-user=SU_USER--ask-su-pass: 输入su的密码例子:123456789ansible 192.168.56.101 \-m shell -a 'whoami &amp;&amp; pwd' \-u billx -k \-S -R root --ask-su-pass输出:192.168.56.101 | SUCCESS | rc=0 &gt;&gt;root/home/billx⚠️ 注意： 这里默认的su模式非su -也就是没有带环境变量的c) become方式(推荐)-b, --become: 更高级的用户权限切换--become-method=BECOME_METHOD: 默认sudo,支持[ sudo | su | pbrun | pfexec | doas | dzdo | ksu | runas | pmrun | enable | machinectl ]--become-user=BECOME_USER: 默认root-K, --ask-become-pass: become对应的用户密码例子:12345678910111213141516ansible -i hosts all \-m shell -a 'whoami &amp;&amp; pwd' \-u billx -k \-b \--become-method=su \--become-user=root \-K# 输出:centos01 | SUCCESS | rc=0 &gt;&gt;root/home/billxcentos02 | SUCCESS | rc=0 &gt;&gt;root/home/billx 模块(modle)使用-m时需要制定不同的模块,也就是简单的Ad_hoc模式a) shell1ansible raleigh -m shell -a 'echo $TERM'⚠️ 注意： 注意 shell 引号的规则. 比如在上面的例子中,如果使用双引号”echo $TERM”,会求出TERM变量在当前系统的值,而我们实际希望的是把这个命令传递 到其它机器执行.b) copy… Inventory文件Ansible可以通过inventory文件同时操作多台主机，默认路径为/etc/ansible/hosts（但安装时并未创建），可通过-i INVENTORY参数指定文件。除默认文件外,还可以同时使用多个inventory文件，并且还可以从动态源,或云上拉取inventory配置信息。 基本1234567# 单台(可以是ip也可以是主机名)127.0.0.1mail.example.com# 非默认22端口127.0.0.1:33example_01 ansible_ssh_host=127.0.0.1 ansible_ssh_port=33 分组/合并1234567891011121314151617181920212223# 分组[example]foo.example.combar.example.com# 多类似主机简写[example]host[01:10].example.comhost[1:10].example.com # 与01写法意义相同host[a:f].example.com# 把一个组作为另一个组的子成员[foo]host1host2[bar]host2host3[example:children]foobar 变量12345678910111213# 主机变量[foo]host1 http_port=80 maxRequestsPerChild=808host2 http_port=303 maxRequestsPerChild=909# 组变量[foo]host1host2[foo:vars]ntp_server=ntp.atlanta.example.comproxy=proxy.atlanta.example.com 参数说明1234567891011121314151617181920212223242526272829303132333435363738# 将要连接的远程主机名.与你想要设定的主机的别名不同的话,可通过此变量设置.ansible_ssh_host# ssh端口号.如果不是默认的端口号,通过此变量设置.ansible_ssh_port# 默认的 ssh 用户名ansible_ssh_user# ssh 密码(这种方式并不安全,我们强烈建议使用 --ask-pass 或 SSH 密钥)ansible_ssh_pass# sudo 密码(这种方式并不安全,我们强烈建议使用 --ask-sudo-pass)ansible_sudo_pass# sudo 命令路径(适用于1.8及以上版本)ansible_sudo_exe (new in version 1.8)# 与主机的连接类型.比如:local, ssh 或者 paramiko. Ansible# 1.2 以前默认使用 paramiko.1.2 以后默认使用 'smart','smart'# 方式会根据是否支持 ControlPersist, 来判断'ssh' 方式是否可行.ansible_connection# ssh 使用的私钥文件.适用于有多个密钥,而你不想使用 SSH 代理的情况.ansible_ssh_private_key_file# 目标系统的shell类型.默认情况下,命令的执行使用 'sh' 语法,可设置为 'csh' 或 'fish'.ansible_shell_type# 目标主机的 python 路径.适用于的情况: 系统中有多个 Python,# 或者命令路径不是"/usr/bin/python",比如 \*BSD, 或者# /usr/bin/python 不是 2.X 版本的 Python.我们不使用# "/usr/bin/env" 机制,因为这要求远程用户的路径设置正确,且要求# "python" 可执行程序名不可为 python以外的名字(实际有可能名为# python26).ansible_python_interpreter*python换成ruby也可以改变ruby的解释器举个例子:123456789some_host ansible_ssh_port=2222 ansible_ssh_user=manageraws_host ansible_ssh_private_key_file=/home/example/.ssh/aws.pemfreebsd_host ansible_python_interpreter=/usr/local/bin/pythonruby_module_host ansible_ruby_interpreter=/usr/bin/ruby.1.9.3[foo]some_host ansible_ssh_host=127.0.0.1[foo:vars]ansible_ssh_user=test 加密使用ansible-vault工具实现对inventory文件的加密操作1234567891011121314151617181920212223242526272829303132333435363738394041# 加密文件:ansible-vault encrypt hosts # 这里hosts是文件名# 输出:New Vault password:Confirm New Vault password:Encryption successfulcat hosts# 输出:$ANSIBLE_VAULT;1.1;AES256343366383330643563303137386461..# 使用加密文件:ansible -i hosts --ask-vault-pass all -m ping -u billx -k# 输出:SSH password:Vault password:centos01 | SUCCESS =&gt; &#123; "changed": false, "ping": "pong"&#125;centos02 | SUCCESS =&gt; &#123; "changed": false, "ping": "pong"&#125;# 解密文件:ansible-vault decrypt hosts# 输出: Vault password:Decryption successfulcat hosts# 输出:[test]centos0[1:2] ansible_ssh_host=192.168.56.101[test:vars]ansible_ssh_port = 22 playbook脚本 demoansible_hosts文件,文件名hosts.12345[test]centos0[1:2] ansible_ssh_host=192.168.56.101[test:vars]ansible_ssh_port = 22playbook文件,文件名test.yml123456789---- hosts: test remote_user: billx become: yes become_user: root become_method: sudo tasks: - name: hello shell: for i in "PermitEmptyPasswords" "PermitRootLogin" "MaxAuthTries" "Ciphers" "MACs" "ListenAddress";do egrep -v '^#|^$' /etc/ssh/sshd_config | egrep -i $i; done;开始执行:1ansible-playbook test.yml -i hosts -k -K -v更多参考:Intro to Playbooks — Ansible Documentation 声明版权： 2018-now，🇨🇳，zangjiaao&lt;zangjiaao@yahoo.com&gt;由家浩创作并维护的zangjiaao's blog博客所有文章除特别声明外，均采用&quot;署名-非商业性使用-相同方式共享4.0(CC BY-NC-SA 4.0)国际许可证&quot;。本文首发于zangjiaao’s blog博客，转载请注明出处。]]></content>
      <categories>
        <category>04_学习笔记</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ansible</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python技巧]]></title>
    <url>%2F2018%2F06%2F22%2FPython%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[概述： python的一些Tips，浓缩都是精华啊… PythonTips收集TODO格式约束字符串和文本Tips01_生成随机数Tips02_大小写转换Tipe03_字符切片列表和字典Tips01_查找最大最小值,以及排序Tips02_创建有序字典函数Tips01_判断变量是否为函数Tips02_装饰器用法Tips03_令局部变量外部可访问Tips04_异常处理原则文件操作Tips01_获取绝对路径Tips02_文件操作方式其他Tips01_HTTP_HEAD_UA构建Tips02_控制台字体颜色声明 TODO列表的切片操作; 格式约束请参考文件操作下的Tips01_获取文件的绝对路径. 字符串和文本 Tips01_生成随机数方法 - 1:1234567import stringimport random# 固定长度：alphabet = string.ascii_letters + string.digitspassword = ''.join(choice(alphabet) for i in range(8))# range里面可以random.randint(5, 10)设定可变长度方法 - 2: 使用secrets，异常方便。参考这篇文章.1234567import secrets# 随机生成[0,n)的intsecrets.randbelow(10)# 随机字符串，还包含符号secrets.token_urlsafe(10)输出：'Drmhze6EPcv0fN_81Bj-nA' Tips02_大小写转换方法 - 1:1234print(str.upper()) # 把所有字符中的小写字母转换成大写字母print(str.lower()) # 把所有字符中的大写字母转换成小写字母print(str.capitalize()) # 把第一个字母转化为大写字母，其余小写print(str.title()) # 把每个单词的第一个字母转化为大写，其余小写 Tipe03_字符切片方法 - 1:data[x:y]：第一索引号码是片的开始（含），并且所述第二索引号码是片的端部（不包括）。1234567data = 'abcdefg'data[1:4]data[1:]# OUT:'bcd''bcdefg'方法 - 2:data[x:y:z]：第三个索引号码代表跨度，默认为1。取所有内容可以省略前面两个索引，例如：12345data = 'abcdefg'data[::2]# OUT：'aceg'方法 - 3:data[-x:-y:-z]：首先需要改变z，也就是先转变方向。然后再调整-x和-y，例如：1234567891011data = 'abcdefg'data[-1::]data[::-1]data[-1:-4:-1]data[-1:-6:-2]# OUT：'g''abcdefg''gfe''gec' 列表和字典同样还包括衍生的: 元组、集合… Tips01_查找最大最小值,以及排序场景 - 1:使用heapq模块的两个函数nlargest()和nsmallest()可以解决(方法前面的n代表number…), 请见演示1和2.如果只是获取列表中的最大一个或者最小一个item, 则可以使用max()和min()更快点.方法 - 1:12345678910import heapqnums = [2, 5, 3, 6, 7, 8, 8, 20]print(heapq.nlargest(3, nums))# OUT:[20, 8, 8]print(heapq.nsmallest(2, nums))# OUT:[2, 3]场景 - 2:使用heapq的heapify()函数可将列表变为一个从小到大排序的列表.如果需要排序, 使用sorted(item)[:N]或者sorted(item)[-N:]更好些.方法 - 2: 对复杂函数可以指定其中的一个参数进行排序(或者取出其中最大的几个)123456789101112131415161718import heapqdata = [ &#123;'name': 'zhangsan', 'age': 18, 'salary': 1000&#125;, &#123;'name': 'lisi', 'age': 24, 'salary': 3000&#125;, &#123;'name': 'wangwu', 'age': 34, 'salary': 8000&#125;,]print(heapq.nsmallest(1, data, key=lambda d: d['age']))# OUT:[&#123;'salary': 1000, 'age': 18, 'name': 'zhangsan'&#125;]# 如果指定的数量与列表大小相等, 那么就是sort排序了print(heapq.nsmallest(len(data), data, key=lambda d: d['age']))# OUT:[&#123;'salary': 1000, 'age': 18, 'name': 'zhangsan'&#125;,&#123;'salary': 3000, 'age': 24, 'name': 'lisi'&#125;,&#123;'salary': 8000, 'age': 34, 'name': 'wangwu'&#125;]# 当然largest同样支持该操作, 这里就不赘述了 Tips02_创建有序字典场景 - 1:想创建一个字典, 并且保证字典能够控制元素的排序. 可以使用collections模块中的OrderedDict类来实现.对于使用yaml作为配置文件的话会使用dict反序列化, 结果导致配置文件会乱序, 可以使用这个方法解决.方法 - 1:12345678910111213141516171819from collections import OrderedDictd = OrderedDict()d['a'] = 1,d['b'] = 2,d['c'] = 3,d['d'] = 4,for key in d: print(key, d[key])# OUT:('a', (1,))('b', (2,))('c', (3,))('d', (4,))# 如果: d = dict(), OUT:('a', (1,))('c', (3,))('b', (2,))('d', (4,)) 函数 Tips01_判断变量是否为函数场景 - 1:判断变量是否为函数，是函数才执行，不是则丢弃。123456789101112131415# 某些比较特殊的函数没办法判断，type结果都不是function&gt;&gt;&gt; import time&gt;&gt;&gt; type(time.time)&lt;class 'builtin_function_or_method'&gt;# 因此先把他做成方法哈哈&gt;&gt;&gt; def func():... return time.time()&gt;&gt;&gt; type(func)&lt;class 'function'&gt;# 意图是传到一个dict中，需要他执行的时候再执行data = &#123; 'test': func&#125;方法 - 1:已不推荐，详见这篇文章.12345678&gt;&gt;&gt; import types&gt;&gt;&gt; if isinstance(data['test'], types.FunctionType):... print(True)...True# 这时候就能在print的位置执行：# data['test']()# 获取到当前的时间戳了方法 - 2:这种方法是python3的，而且不用import types，并且语法更精炼。12&gt;&gt;&gt; callable(data['test'])True⚠️ 注意： 如果这是针对Python 3.x，但在3.2之前，请检查该对象是否具有__call__属性。你可以这样做：12&gt;&gt;&gt; hasattr(data['func'], '__call__')True Tips02_装饰器用法方法 - 1: 单个装饰器1234567891011def decorator(func): # func为形参，可自定义 def wrapper(name): # 这里被装饰函数是啥就要传入一致的参数 func(name) # 这里可以直接调用 print('nice to meet you') return wrapper # 这里返回内部函数，但是函数不能带()，是不能执行的@decorator # 装饰器的名字，可自定义def some_func(name): # 要装饰的函数 print(name)some_func('my name is') # 这里才正儿八经执行了方法 - 2: 单个装饰器(带返回值)Demo: day15_decorator.py1234567891011121314151617181920212223242526272829def decorator(func): def inner(a, b): print('add &gt;&gt; something here.') result = func(a, b) print('add &gt;&gt; another here.') return result return inner@decoratordef hello_world(a, b): if a == b: print('hello &gt;&gt; a like b!') return True else: print('hello &gt;&gt; a unlike b..') return Falsea = 1b = 0output = hello_world(a, b)print('return &gt;&gt;', output)# OUT:add &gt;&gt; something here.hello &gt;&gt; a unlike b..add &gt;&gt; another here.return &gt;&gt; False方法 - 3: 多个装饰器123456789101112131415161718def decorator(func): def wrapper(): func() print('decorator 01') return wrapperdef decorator2(func): def wrapper(): func() print('decorator 02') return wrapper@decorator@decorator2def some_func(): print('helloworld')some_func()方法 - 4: 带可变参数123456789101112131415161718192021222324def decorator(func): def wrapper(message, *args, **kargs): func(message, *args, **kargs) print('nice to meet you') print('装饰器处理过的message:&#123;&#125;'.format(message)) return wrapper@decoratordef some_func(message, *args, **kargs): print(message) for i in args: print(i) print(kargs)list_data = ['a', 'b', 'c']dict_data = &#123; 'd': '1', 'e': '2'&#125;# 单个传入也可以，kargs则为&#123;&#125;# some_func('单个可变参数:', *list_data)some_func('多个可变参数:', *list_data, **dict_data)方法 - 5: 装饰类中的函数1234567891011121314# 注意这里必须在类外面def make_more_pretty(func): def inner(self): # 这里要将self传过来 func(self) # 同样 print('Fine') return innerclass A: @make_more_pretty def some_func(self): print('hello world')a = A()a.some_func()方法 - 6: 附加参数(貌似没办法传变量)1234567891011121314151617181920212223242526def update(update): def decorator(func): print(update) def wrapper(message, *args, **kargs): func(message, *args, **kargs) print('nice to meet you') print('装饰器处理过的message:&#123;&#125;'.format(message)) return wrapper return decorator@update('update') # 这里decorator换updatedef some_func(message, *args, **kargs): print(message) for i in args: print(i) print(kargs)list_data = ['a', 'b', 'c']dict_data = &#123; 'd': '1', 'e': '2'&#125;# some_func('单个可变参数:', *list_data)some_func('多个可变参数:', *list_data, **dict_data)用途 - 1: 设定初始值，或者保持一个变量的值可以用来让上层函数（指closing函数）的变量持久化（设置个初值或者定值）。123456789101112131415def foo(x): def bar(var): return x + var return bar# 我一开始有10ml牛奶和20ml水water = foo(10)milk = foo(20)# 我各买20ml, 现在我有30ml水，40ml牛奶# 初始值被保留了print(water(20))print(milk(20))# 因此这个方法可以用于设置初值 Tips03_令局部变量外部可访问方法 - 1:如何让局部变量变得外层可以访问1234567891011121314def outer_function(): a = 5 def inner_function(): nonlocal a # 关键在于这个 a = 10 print("Inner function: ",a) inner_function() print("Outer function: ",a)outer_function()# OUT：Inner function: 10Outer function: 5 Tips04_异常处理原则格式：流程： 文件操作 Tips01_获取绝对路径参考: python获取文件的绝对路径 - CSDN博客使用类中的__file__属性1current_dir = os.path.dirname(__file__)或者, 使用inspect下的getfile()获取到当前文件的绝对路径, 然后在通过os.path.dirname获取到当前文件所在的路径.1234import inspectimport oscurrent_dir = os.path.dirname(inspect.getfile(inspect.currentframe()))后面可以使用os.path拼接相对路径1self.path = os.path.join(current_dir, 'conf/demo_yaml.yml')场景 - 1: 配置文件的读取.在跨目录引用父类的场景中, 如果父类中使用了相对路径的方式获取文件路径, 则子类在触发相关动作的时候会出现&quot;FileNotFound&quot;错误, 因此需要在父类中使用绝对路径获取文件路径.例如当前项目的目录结构如下:12345conf/ default.ini # 表示conf/defult.ini, 下同script/ child.pyfather.pyfather.py中有对default.ini配置文件的引用动作:12345678910class Father: def __init__(self): self.path = 'conf/default.ini' # !!这里 def read(self): with open(self.path, 'r') as f: for line in f: pass print('read!!')child.py中继承了父类, 并且想要调用父类的read()方法:12345678910111213141516171819from test_import import Fatherclass Child(Father): def __init__(self): super(Child, self).__init__() def run(self): self.read() def get_path(self): return self.pathif __name__ == '__main__': child = Child() path = child.get_path() # print(path) child.run() # 这里是封装了一下..实际上还是调用了父类方法执行会报错:1FileNotFoundError: [Errno 2] No such file or directory: &apos;conf/default.ini&apos;原因自然是程序不会以father的目录为当前目录, 而是以child的, 所以找不到conf目录方法 - 1:解决方案就是要在父类中获取到文件的绝对路径, 这样父类就能找到文件了.修改后的father.py如下:12345678class Father: def __init__(self): #self.path = 'conf/default.ini' current_dir = os.path.dirname(__file__) self.path = os.path.join (current_dir, 'conf/default.yml') ... Tips02_文件操作方式r: open for reading (default)w: open for writing, truncating the file firstx: open for exclusive creation, failing if the file already existsa: open for writing, appending to the end of the file if it existsb: binary modet: text mode (default)+: open a disk file for updating (reading and writing)U: universal newlines mode (deprecated)场景 - 1:写日志的情况, 如果上一个日志存在, 那么就将其重命名.方法 - 1:首先判断默认的日志文件是否存在, 存在则将把原始的log文件使用os.rename()进行重命名, 再进行文件创建.123456789101112131415161718192021import loggingimport osimport timepath = 'log/logging_from_logger01.log'main_log = logging.Logger(name='main', level=logging.INFO)if os.path.exists(path): # 1. 获取原日志的目录 f_dir = os.path.dirname(path) # 2. 获取原日志的名称以及后缀 f_name, f_ext = os.path.splitext(os.path.basename(path)) # 3. 重新组合文件名 new_name = ''.join([f_name, time.strftime('_%Y%m%d%H%M%S', time.localtime()), f_ext]) os.rename(path, os.path.join(f_dir, new_name))main_log_handle = logging.FileHandler(path, mode='xt')main_log.addHandler(main_log_handle)main_log.info('test') 其他 Tips01_HTTP_HEAD_UA构建12345678910111213141516from urllib.parse import urlparse as parsy...user_agents = ['Mozilla/5.0 (X11; Linux i686; rv:60.0) Gecko/20100101 Firefox/60.0','Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36''Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36 OPR/43.0.2442.991'] headers = &#123; 'Host' : parsy(url).hostname, 'User-Agent' : random.choice(user_agents), 'Accept' : 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8', 'Accept-Language' : 'en-US,en;q=0.5', 'Accept-Encoding' : 'deflate', 'Connection' : 'close', 'DNT' : '1', 'Connection' : 'close'&#125; Tips02_控制台字体颜色最后几个是比较常用打赢日志的类别标识，了解一下。1234567891011white = &apos;\033[97m&apos;green = &apos;\033[92m&apos;red = &apos;\033[91m&apos;yellow = &apos;\033[93m&apos;end = &apos;\033[0m&apos;back = &apos;\033[7;91m&apos;info = &apos;\033[33m[!]\033[0m&apos;que = &apos;\033[34m[?]\033[0m&apos;bad = &apos;\033[31m[-]\033[0m&apos;good = &apos;\033[32m[+]\033[0m&apos;run = &apos;\033[97m[~]\033[0m&apos;典型的bash颜色1print(&apos;\033[1;97m things... \033[0m&apos;) 声明版权： 2018-now，🇨🇳，zangjiaao&lt;zangjiaao@yahoo.com&gt;由家浩创作并维护的zangjiaao's blog博客所有文章除特别声明外，均采用&quot;署名-非商业性使用-相同方式共享4.0(CC BY-NC-SA 4.0)国际许可证&quot;。本文首发于zangjiaao’s blog博客，转载请注明出处。]]></content>
      <categories>
        <category>04_学习笔记</category>
      </categories>
      <tags>
        <tag>速查</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Regular正则笔记]]></title>
    <url>%2F2018%2F06%2F21%2FRegular%E6%AD%A3%E5%88%99%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[概述： 在学习Python re库的时候发现正则是神器，不过比较难记，所以在这里备忘… 正则表达式Tips大小写数量贪婪/非贪婪预查(?:pattern)(?=pattern)(?!pattern)(?&lt;=pattern)声明 大小写不区分大小写： 下面是两种写法：12345&gt;&gt;&gt; re.findall('(?i:p)ython', data)['python', 'Python']&gt;&gt;&gt; re.findall('(?i)python')['python', 'Python']区分大小写： 默认是区分的，强制区分：12&gt;&gt;&gt; re.findall('(?-i:p)ython')['python'] 数量*：0或更多次+：1或更多次?：0或1次 贪婪/非贪婪默认是贪婪模式，加上?后变为非贪婪模式：*?、+?、??均为非贪婪模式12345&gt;&gt;&gt; data = '&lt;a&gt; b &lt;c&gt;'&gt;&gt;&gt; re.findall('\&lt;.*\&gt;', data)['&lt;a&gt; b &lt;c&gt;']&gt;&gt;&gt; re.findall('\&lt;.*?\&gt;', data)['&lt;a&gt;', '&lt;c&gt;']{m,n}?同样转化为非贪婪模式12345&gt;&gt;&gt; data = 'aaaaaa'&gt;&gt;&gt; re.findall('a&#123;3,5&#125;', data)['aaaaa']&gt;&gt;&gt; re.findall('a&#123;3,5&#125;?', data)['aaa', 'aaa'] 预查 (?:pattern)(?:pattern): 模糊查找, 可有可无, 并且将匹配到的结果也包含在全部结果之中.例如:12345678data = """line."""prog = re.compile(r'line(?:\.)', flags=0)result = prog.search(data)print(result.group())# 结果:line.pattern中支持|可同时查找多个不同结果. (?=pattern)x(?=pattern): 正向肯定预查(look ahead positive assert), 同样是模糊查找, 如果匹配到了pattern, 那就认为前面的表达式x成立. 这与(?:)很相似, 不过输出中不包含pattern所匹配的内容, 而只有x.例如:12345678data = """line."""prog = re.compile(r'line(?=\.)', flags=0)result = prog.search(data)print(result.group())# 结果, 注意结尾的句号:linepattern中支持|可同时查找多个不同结果. (?!pattern)如果说(?=)是白名单, 那么(?!)就是黑名单版本. (?&lt;=pattern)反向(look behind)肯定预查, 就是查后面的表达式 ,举个例子:有以下字符串:ABCA(?=B): 可以匹配, 结果为A;(?=B)C: 不能匹配;(?&lt;=B)C: 可以匹配, 结果为C; 声明版权： 2018-now，🇨🇳，zangjiaao&lt;zangjiaao@yahoo.com&gt;由家浩创作并维护的zangjiaao's blog博客所有文章除特别声明外，均采用&quot;署名-非商业性使用-相同方式共享4.0(CC BY-NC-SA 4.0)国际许可证&quot;。本文首发于zangjiaao’s blog博客，转载请注明出处。]]></content>
  </entry>
  <entry>
    <title><![CDATA[SQL语法速查]]></title>
    <url>%2F2018%2F06%2F14%2FSQL%E8%AF%AD%E6%B3%95%E9%80%9F%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[概述： 在使用python控制mysql(mariadb)的时候不懂SQL真是急死人😰…学习一下SQL语法，填一下以前的坑…主要参考《MySQL必知必会》这本教材，写的不错安利一下~ SQL语法速查语法约定增创建数据库_CREATE_DATABASE创建表_CREATE_TABLE删删除数据库_DROP_DATABASE删除表_DROP_TABLE删除条目_DELETE改修改数据_UPDATE插入数据_INSERT_INTO查表中列信息_SHOW_COLUMNS限制_LIMIT去重_DISTINCT排序_ORDER_BY过滤_WHERE迁移查找数据通配符搜索函数声明 语法约定语法遵循在MySQL中help中的结果, 使用以下格式描述.{A|B}表示&quot;A&quot;或者&quot;B&quot;必须有一个;[A | B]表示&quot;A&quot;或者&quot;B&quot;或者没有;[A]表示&quot;A&quot;或者没有;A[ B]表示&quot;A&quot;或者&quot;A B&quot;.(A,)表示括号包裹的数据, 没有特殊含义.例如:1234SHOW [FULL] COLUMNS&#123;FROM | IN&#125; tbl_name[&#123;FROM | IN&#125; db_name][LIKE 'pattern' | WHERE expr]每个项目的说明格式为:语法: 顾名思义.说明: 对于语法中一些关键字的说明.例子: (可选)一些常用的例子, 各个例子可以使用或来分割.补充: (可选)一些特殊情况的说明. 增 创建数据库_CREATE_DATABASE语法:123456CREATE &#123;DATABASE | SCHEMA&#125; [IF NOT EXISTS] db_name [create_specification] ...create_specification: [DEFAULT] CHARACTER SET [=] charset_name | [DEFAULT] COLLATE [=] collation_name说明:IF NOT EXISTS: 表示在创建数据库之前, 先判断数据库是否存在, 存在就不创建.create_specification: 创建时的一些定义, 可以在创建数据库之前配置数据库的编码格式, Mariadb默认使用latin1, 中文支持不太好, 可以改为utf8, 更多支持可见Supported Character Sets and Collations.例子:1CREATE DATABASE tmp;或:123CREATE DATABASE tmp CHARACTER SET = 'utf8' COLLATE = 'utf8_general_ci';补充:场景: 创建数据库后, 发现数据库编码格式不对, 导致中文字符乱码.解决方案: 需要修改数据库的字符编码.首先, 查看当前数据库编码(MariaDB下):1SELECT * FROM INFORMATION_SCHEMA.SCHEMATA;然后, 修改对应数据库的编码:123ALTER DATABASE dbname CHARACTER SET = 'utf8' COLLATE = 'utf8_general_ci';了解更多, 可查看Setting Character Sets and Collations. 创建表_CREATE_TABLE语法:1234567891011121314151617CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name (create_definition,...) [table_options] [partition_options]Or:CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name [(create_definition,...)] [table_options] [partition_options] select_statementOr:CREATE [TEMPORARY] TABLE [IF NOT EXISTS] tbl_name &#123; LIKE old_tbl_name | (LIKE old_tbl_name) &#125;说明:TEMPORARY: 创建零时表, 尝试创建表后, 查询发现并不存在, 不常用.create_definition: 表中各字段的定义, 格式为:1234col_name data_type column_definition# 例如id INT(5) NOT NULL AUTO_INCREMENT PRIMARY KEY常用的几个column_definition:[PRIMARY ]KEY: 设置主键, PRIMARY可以不写, 一个表只能有一个主键;[NOT NULL| NULL]: 设置为非空或者为空;AUTO_INCREMENT: 设置是否自增, 可;DEFAULT default_value: 设置创建时默认的内容;常用的几个data_type, 更多可以看官方文档:INT|INTEGER[(length)]: 整数, 俩一个意思;CHAR[(length)] [CHARACTER SET charset_name] [COLLATE collation_name]: 字符串, 同时可以设置字符编码;VARCHAR(length) [CHARACTER SET charset_name] [COLLATE collation_name]: 可变长字符串, 同样可以设置字符编码;BINARY[(length)]: 二进制;VARBINARY(length): 可变长二进制;DATE|TIME|TIMESTAMP|DATETIME|YEAR: 时间格式, 但是只有TIMESTAMP可以自动在插入数据或者更新时自动更新, 其他的格式都是起到限制输入的作用, 可以参考[补充1].TEXT|:BOOL: 布尔值, 其实就是TINIYINT(1), 非0的数都会为truetable_options: 表的一些选项, 可以在这里指定ENGINE之类的, 具体可以键入help CREATE TABLE查询.例子:1234567CREATE TABLE user( id INT(5) NOT NULL AUTO_INCREMENT, username VARCHAR(20) NOT NULL, userpass VARCHAR(20) NOT NULL, email VARCHAR(50), PRIMARY KEY (id))⚠️ 注意1: 只允许有一个自动列, 例如AUTO_INCREMENT, 并且其必须被定义为主键, 例如PRIMARY KEY (id).或:12345CREATE TABLE IF NOT EXISTS tbl_name( id INT NOT NULL AUTO_INCREMENT KEY, age INT(2) DEFAULT 18, name CHAR(50) NOT NULL) ENGINE = InnoDB, CHARACTER SET = utf8;补充1:以下为了方便回忆, 具体可以看官方文档.DATE: YYYY-MM-DD, 分隔符可以是任意符号, 但是最终都会被转换为默认格式.TIME: HH:MM:SS.ssssss, 最后的时间戳最多6位, 不指定也可以.DATETIME: YYYY-MM-DD HH:MM:SSTIMESTAMP: 同上, 但是是自动生成自动更新YEAR: 限制了四位数字 删 删除数据库_DROP_DATABASE语法:1DROP DATABASE `db_name`; 删除表_DROP_TABLE语法:1DROP TABLE `table_name`; 删除条目_DELETE语法:12DELETE FROM userWHERE username=%s 改 修改数据_UPDATE语法:12345678910111213# 单表修改语法:UPDATE [LOW_PRIORITY] [IGNORE] table_reference SET col_name1=&#123;expr1|DEFAULT&#125; [, col_name2=&#123;expr2|DEFAULT&#125;] ... [WHERE where_condition] [ORDER BY ...] [LIMIT row_count]# 多表修改语法:UPDATE [LOW_PRIORITY] [IGNORE] table_references SET col_name1=&#123;expr1|DEFAULT&#125; [, col_name2=&#123;expr2|DEFAULT&#125;] ... [WHERE where_condition]支持同时修改多个表, 但修改多个表时无法使用ORDER BY以及LIMIT关键字.说明:例子:123UPDATE userSET username=%sWHERE username=%s注意这里的顺序，前面才是更新的内容 插入数据_INSERT_INTO语法:12345INSERT INTO test( username, userpass, email)VALUE(%s, %s, %s) 查 表中列信息_SHOW_COLUMNS语法:123SHOW [FULL] COLUMNS&#123;FROM | IN&#125; tbl_name[&#123;FROM | IN&#125; db_name] [LIKE 'pattern' | WHERE expr]例子:12SHOW COLUMNSFROM tmp;或:123# 显示更多信息SHOW FULL COLUMNSFROM tmp;或:12SHOW COLUMNSFROM test.tmp;或:123SHOW COLUMNSFROM tmpFROM db_name 限制_LIMIT语法1:123SELECT `col_name`FROM `tbl_name`LIMIT 1, 10表示LIMIT 从第几行开始，输出的最大行数, 单个代表LIMIT 输出的最大行数。⚠️注意: “从第几行开始&quot;的索引号是从0开始的, 而不是1, 因此LIMIT 1, 1实际查询的第二行, LIMIT 0, 1才是从第一行开始. 见&quot;例子1”.语法2:从MySQL5开始支持OFFSET, 代替&quot;从第几行开始&quot;, 语法如下:123SELECT `col_name`FROM `tbl_name`LIMIT 10 OFFSET 1这里所输出的结果与&quot;语法1&quot;一致.例子1:tmp表中有以下数据:123456789MariaDB [test]&gt; SELECT * FROM tmp;+----+------+| id | name |+----+------+| 1 | A || 2 | B || 3 | C || 4 | D |+----+------+使用LIMIT 1, 1限制查询, 输出了第二行.123456MariaDB [test]&gt; SELECT * FROM tmp LIMIT 1, 1;+----+------+| id | name |+----+------+| 2 | B |+----+------+使用LIMIT 0, 1查询, 才输出第一行.123456MariaDB [test]&gt; SELECT * FROM tmp LIMIT 0, 1;+----+------+| id | name |+----+------+| 1 | A |+----+------+ 去重_DISTINCT语法:12SELECT DISTINCT `column_name1`, `column_name2`FROM `table_name`;⚠️注意: 如果指定多列, 只有指定的所有列都相同才会被过滤掉, 见本节[说明2].说明1:以下演示单列查询. 有以下数据:1234567891011121314MariaDB [test]&gt; select * from distinct_test;+---------+| vend_id |+---------+| 1001 || 1001 || 1002 || 1003 || 1004 || 1004 || 1004 || 1005 |+---------+8 rows in set (0.001 sec)希望某列不重复出现:1234567891011MariaDB [test]&gt; select distinct vend_id from distinct_test;+---------+| vend_id |+---------+| 1001 || 1002 || 1003 || 1004 || 1005 |+---------+5 rows in set (0.001 sec)说明2:演示多列查询. 有以下数据:12345678910MariaDB [test]&gt; select * from tmp;+---------+------+| vend_id | name |+---------+------+| 1001 | A || 1001 | B || 1001 | C || 1002 | C || 1002 | C |+---------+------+其中只有最后两行是完全相同的, 当使用DISTINCT过滤时, 只会过滤这两行.123456789MariaDB [test]&gt; select distinct vend_id, name from tmp;+---------+------+| vend_id | name |+---------+------+| 1001 | A || 1001 | B || 1001 | C || 1002 | C |+---------+------+ 排序_ORDER_BY语法:123SELECT *FROM 'tbl_name'ORDER BY 'col_name1' DESC, 'col_name2' ASC,col_name*可以是多个, 指定多个&quot;col_name&quot;会多行排序. 按多个列排序, 会有限排序&quot;col_name1&quot;, 然后再将结果按照&quot;col_name2&quot;来排序.ASC|DESC表示升序和降序. 如果不指定, 那么默认是升序. 过滤_WHERE语法1: 基本过滤123SELECT 'select_expr'FROM 'tbl_name'WHERE id = 1;或者:1WHERE id BETWEEN 1 AND 10;或者:12# 和上一条BETWEEN功能相仿.WHERE id IN (1, 10);或者:1WHERE name IS NULL;BETWEEN是查找范围内的数据, 使用AND分割条件.IS NULL是查找空值的.支持的条件操作符:语法2: 组合过滤支持使用AND | OR来组合WHERE查询语句.123SELECT 'select_expr'FROM 'tbl_name'WHERE ('col_name1' = 1 OR 'col_name1' = 2) AND 'col_name2' &gt; 10这里SQL会优先判断AND, 但是用()包裹的会最优先判断. 迁移 查找数据123456789SELECT usernameFROM userWHERE username != 'test01'# 按照email排序，然后再用userpass排序，DECS表示倒序ORDER BY email, userpass DESC# 只显示从第0行开始，的10行（不是第10行）# LIMIT只能在末尾LIMIT 0, 10123WHERE username = 'test02'OR email = 'test02@qq.com'AND userpass = 'qwe123'1234WHERE username BETWEEN 1 AND 10# 可能只针对数字类型WHERE username NOT IN (1, 10)1234567WHERE username# 只匹配一个字符LIKE '_00'# 类似于'.00.'LIKE '%00%' 通配符搜索12345678WHERE usernameREGEXP '.0.'# 非1|2|3REGEXP '[^123]'# 转义REGEXP '\\.'匹配元字符匹配字符类重复元字符定位元字符 函数Content()在mysq中用来拼接字段，其他数据库多数使用+或者||：123456789101112131415SELECT Concat(username, userpass)FROM userWHERE username = '500'输出：+----------------------------+| Concat(username, userpass) |+----------------------------+| 500qwe123 |+----------------------------+# 当然也可以像字符串一样操作SELECT Concat(username, '\(', userpass, '\)')FROM userWHERE username = '500';RTrim()和LTrim()以及Trim()用于去掉左边或者右边的，或者同时两边的空格。 声明版权： 2018-now，🇨🇳，zangjiaao&lt;zangjiaao@yahoo.com&gt;由家浩创作并维护的zangjiaao's blog博客所有文章除特别声明外，均采用&quot;署名-非商业性使用-相同方式共享4.0(CC BY-NC-SA 4.0)国际许可证&quot;。本文首发于zangjiaao’s blog博客，转载请注明出处。]]></content>
      <categories>
        <category>04_学习笔记</category>
      </categories>
      <tags>
        <tag>速查</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python模块手册]]></title>
    <url>%2F2018%2F06%2F13%2FPython%E6%A8%A1%E5%9D%97%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[概述： 主要用于备忘，记录一些我常用到的一些类的Tips和特性(*基于python3)…官方的ApiDoc… Python模块手册TODOos(系统相关)paramiku(SSH控制端)安装初始化连接建立channel最佳实践su方式运行logging(日志)XMind一图搞懂练习Demopymysql(mysql客户端)常规流程with简化连接防SQL注入查询数据获取获取最新自增ID游标操控错误回滚调用存储过程异常处理argparse(用户传参控制)configparser(配置文件控制)创建读取传统模式(更高级)ini文件格式配置文件中的变量Comment与parser冲突问题自定义booleanvalue需要大写方案re(正则匹配)re.compile_编译PyYAML输出的styleYaml特殊格式time(操作时间数据)XMind 一图读懂声明 TODO学习os模块学习time以及datetime模块学习threading和queue模块研究collection和heapq模块 os(系统相关)os.path参考:python os.path模块常用方法详解 - 巫谢 - 博客园5.19 创建临时文件和文件夹 — python3-cookbook 3.0.0 文档 paramiku(SSH控制端)参考这篇文章.官方API文档. 安装1sudo pip instal paramiko 初始化连接123456789101112import paramikossh = paramiko.SSHClient()#允许连接到不在本机know_hosts中的主机ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())# 以密钥对方式建立:ssh_client.connect("IP", port, username="username", password="password")# 以密钥对方式建立:ssh.connect('IP',port, '用户名', key_filename='/home/xxx/.ssh/id_rsa', passphrase='xxx')可执行单条命令,通过传统std接收输入输出,以及error:12stdin, stdout, stderr = ssh_client.exec_command('ls -l')print(stdout.readlines()) 建立channel123456789101112with ssh_client.invoke_shell() as ssh_channel: ssh_channel.send('whoami\n') buff = ssh_channel.recv(999)channel = ssh.invoke_shell()if not recv_ready(): return('连接未就绪')channel.send('su - billx' + '\n')buff = channel.recv(9999)print(buff)channel.close() 最佳实践 su方式运行123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import paramikoimport timeimport copyimport ressh_client = paramiko.SSHClient()ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())ssh_client.connect('192.168.56.101', username='billx', password='qwe123')def exec_cmd(cmd): with ssh_client.invoke_shell() as chann: while not chann.recv_ready(): time.sleep(1) print('delayA..') while chann.recv_ready(): chann.recv(1024) su_pwd = 'qwe123' chann.send('su - root\n') while not chann.recv_ready(): time.sleep(1) print('delayB..') chann.send(su_pwd + '\n') while not chann.recv_ready(): time.sleep(1) print('delayC..') while chann.recv_ready(): data = chann.recv(1024) chann.send(cmd + '\n') while not chann.recv_ready(): time.sleep(1) print('delayD..') data = b'' while True: if not chann.recv_ready(): data = filter(lambda x: not re.match('\[.*?][#$]\s+$', x), data.decode().split('\r\n')[1:]) print('\n'.join(data)) break tmp = chann.recv(1024) data += tmpcmd = 'ss -tulnap'exec_cmd(cmd)print('\ndone..\n')cmd = 'pwd'exec_cmd(cmd) logging(日志)python logging模块使用教程 XMind一图搞懂xmind文件(密码:bpwr) 练习Demobillxllid/python_learn pymysql(mysql客户端) 常规流程1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import pymysql# 建立连接conn = pymysql.connect( host = 'localhost', port = 3306, user = 'tester', passwd = 'qwe123', db = 'test', charset = 'utf8')# 创建游标try: cursor = connect.cursor()except pymysql.MySQLError as e: print('Connect error. Detail: %s' % str(e))# 构建SQL语句sql = """SELECT VERSION()"""# 执行try: cursor.execute(sql)except pymysql.ProgrammingError as e: print(e) exit()# 获取响应r = cursor.fetchall()print(r)# INSERT、UPDATE需要commit()，否则无法实际修改数据conn.commit()# 关闭游标和连接cursor.close()conn.close() with简化连接免得每次都要conn.close()1234567891011121314151617181920212223# 使用with简化连接过程，每次都连接关闭很麻烦，使用上下文管理，简化连接过程import pymysqlimport contextlib# 定义上下文管理器，连接后自动关闭连接@contextlib.contextmanagerdef mysql(host=&apos;127.0.0.1&apos;, port=3306, user=&apos;blog&apos;, passwd=&apos;123456&apos;, db=&apos;blog&apos;, charset=&apos;utf8&apos;): conn = pymysql.connect(host=host, port=port, user=user, passwd=passwd, db=db, charset=charset) cursor = conn.cursor(cursor=pymysql.cursors.DictCursor) try: yield cursor finally: conn.commit() cursor.close() conn.close()# 执行sqlwith mysql() as cursor: # 左连接查询 r = cursor.execute(&quot;select * from users as u left join articles as a on u.id = a.user_id where a.user_id = 2&quot;) result = cursor.fetchall() print(result) 防SQL注入参数化查询内部执行参数化生成的SQL语句，对特殊字符进行了加\转义，避免注入语句生成。1234567891011cursor.execute("""select username,passwordfrom tb7where username=%s and password=%s""", (username, password))# 或者将sql语句与data拆分也可以sql = """ ..."""data = ( .. ,)cursor.execute(sql, data)在插入多行数据时，使用executemay效果要更好。1234567cursor.executemany("""INSERT INTO user( username, userpass, email)VALUE(%s, %s, %s)""", [('A', '123', '123@qq.com'), ('B', '456', '456@qq.com')])存储过程12sql1="select * from users where nid&gt;? and nid&lt;?"cursor.callproc('proc_sql', args=(11, 15, sql1))更多详见python中操作mysql的pymysql模块详解。 查询数据获取12345678# 获取第一行数据row_1 = cursor.fetchone()# 获取前n行数据row_n = cursor.fetchmany(3)# 获取所有数据row_3 = cursor.fetchall() 获取最新自增ID1new_id = cursor.lastrowid 游标操控12345# 相对当前位置移动cursor.scroll(1,mode='relative')# 相对绝对位置移动cursor.scroll(2,mode='absolute') 错误回滚12345678try: cursor.execute(sql) conn.commit()except: # 如果发生错误则回滚 conn.rollback() 调用存储过程无参存储过程12345678#游标设置为字典类型cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)#等价于cursor.execute("call p2()")cursor.callproc('p2')row_1 = cursor.fetchone()print(row_1)有参存储过程12345678910cursor = conn.cursor(cursor=pymysql.cursors.DictCursor)cursor.callproc('p1', args=(1, 22, 3, 4))# 获取执行完存储的参数,参数@开头cursor.execute("select @p1,@_p1_1,@_p1_2,@_p1_3")# &#123;u'@_p1_1': 22, u'@p1': None, u'@_p1_2': 103, u'@_p1_3': 24&#125;row_1 = cursor.fetchone()print(row_1) 异常处理请参考pymysql异常处理文末。 argparse(用户传参控制)可以用argparse替代原来的getparse以及optparse了。更多方法可以通过help()以及PEP 389 – argparse - New Command Line Parsing Module获取。123456789101112131415161718import argparsedef get_parser(): parser = argparse.ArgumentParser(description='scanless, public port scan scrapper') parser.add_argument('-v', '--version', help='display the current version', action='store_true') parser.add_argument('-t', '--target', help='ip or domain to scan', type=str) parser.add_argument('-s', '--scanner', help='scanner to use (default: hackertarget)', type=str, default='hackertarget') return parserdef main(): parser = get_parser() args = vars(parser.parse_args())if __name__ == '__main__': main() configparser(配置文件控制)参考：14.2. configparser — Configuration file parser — Python 3.6.6rc1 documentation。 创建12345678910111213141516171819import configparserconfig = configparser.ConfigParser()# 创建空分类config['EMPTY'] = &#123;&#125;# 赋值config['EMPTY']['test'] = 'test'# 优雅方式赋值..x = config['EMPTY']x['test2'] = 'test2'# 创建时直接赋值..config['DEFAULT'] = &#123; 'test3': 'test3', 'test4': 'test4',&#125;# 修改config['DEFAULT']['test4'] = 'test5'# 写入文件with open('test_pyconfig.ini', 'w') as configfile: config.write(configfile)生成如下配置文件:12345678# test_pyconfig.ini[DEFAULT]test3 = test3test4 = test5[EMPTY]test = testtest2 = test2 读取1234import configparserconfig = configparser.ConfigParser()config.read('example.ini') 传统模式(更高级)创建1234567891011121314151617181920import configparserconfig = configparser.RawConfigParser()# Please note that using RawConfigParser's set functions, you can assign# non-string values to keys internally, but will receive an error when# attempting to write to a file or when you get it in non-raw mode. Setting# values using the mapping protocol or ConfigParser's set() does not allow# such assignments to take place.config.add_section('Section1')config.set('Section1', 'an_int', '15')config.set('Section1', 'a_bool', 'true')config.set('Section1', 'a_float', '3.1415')config.set('Section1', 'baz', 'fun')config.set('Section1', 'bar', 'Python')config.set('Section1', 'foo', '%(bar)s is %(baz)s!')# Writing our configuration file to 'example.cfg'with open('example.cfg', 'w') as configfile: config.write(configfile)读取123456789101112131415import configparserconfig = configparser.RawConfigParser()config.read('example.cfg')# getfloat() raises an exception if the value is not a float# getint() and getboolean() also do this for their respective typesa_float = config.getfloat('Section1', 'a_float')an_int = config.getint('Section1', 'an_int')print(a_float + an_int)# Notice that the next output does not interpolate '%(bar)s' or '%(baz)s'.# This is because we are using a RawConfigParser().if config.getboolean('Section1', 'a_bool'): print(config.get('Section1', 'foo'))一些附加用法123456789101112131415161718192021222324252627282930313233343536373839import configparsercfg = configparser.ConfigParser()cfg.read('example.cfg')# Set the optional *raw* argument of get() to True if you wish to disable# interpolation in a single get operation.print(cfg.get('Section1', 'foo', raw=False)) # -&gt; "Python is fun!"print(cfg.get('Section1', 'foo', raw=True)) # -&gt; "%(bar)s is %(baz)s!"# The optional *vars* argument is a dict with members that will take# precedence in interpolation.print(cfg.get('Section1', 'foo', vars=&#123;'bar': 'Documentation','baz': 'evil'&#125;))# The optional *fallback* argument can be used to provide a fallback valueprint(cfg.get('Section1', 'foo')) # -&gt; "Python is fun!"print(cfg.get('Section1', 'foo', fallback='Monty is not.')) # -&gt; "Python is fun!"print(cfg.get('Section1', 'monster', fallback='No such things as monsters.')) # -&gt; "No such things as monsters."# A bare print(cfg.get('Section1', 'monster')) would raise NoOptionError# but we can also use:print(cfg.get('Section1', 'monster', fallback=None)) # -&gt; None# New instance with 'bar' and 'baz' defaulting to 'Life' and 'hard' eachconfig = configparser.ConfigParser(&#123;'bar': 'Life', 'baz': 'hard'&#125;)config.read('example.cfg')print(config.get('Section1', 'foo')) # -&gt; "Python is fun!"config.remove_option('Section1', 'bar')config.remove_option('Section1', 'baz')print(config.get('Section1', 'foo')) # -&gt; "Life is hard!" ini文件格式配置文件中遵守以下规则:section区分大小写parser不区分大小写,并且key和KEY或者Key都代表同一个key,他们必须唯一1234567891011121314151617181920212223242526[DEFAULT]default_key: every section has me[simple values]key = valuespace in key = allowedspace in value = allowedspace around the delimiter = obviously yesyou can also use : to delimit keys from values[all value are stings]values like this: 10000or this: 3.1415926all things is string, so you can use API to get them directly[multiline values]chorus: I'm a lumberjack, and I'm okey I sleep all night and I work all day[No values]key_without_valueempty string value here =[you can alse use comments]# like this; or this 配置文件中的变量基础用法: 可以在一个section中使用(默认interpolation是configparser.BasicInterpolation):1234[Paths]home_dir: /Usersmy_dir: %(home_dir)s/lumberjeckmy_pictures: %(home_dir)s/Pictures举个例子, 有如下配置文件:123[MyPath]home_dir: /homemy_home: %(home_dir)s/billxpython中读取:12345config = configparser.ConfigParser()config.read('test_pyconfig.ini')sections = config.sections()print(sections)print(config['MyPath'].get('my_home'))当然,也可以在其他section中引用,不过需要修改默认的interpolation为configparser.ExtendInterpolation12345678[Common]home_dir: /homelibrary_dir: /Library[MoreAdvanceUsage]home_dir: /homemy_home: $&#123;home_dir&#125;/billxmy_library: $&#123;Common:library_dir&#125;/billx使用configparse时需要修改默认的interpolation配置12345config = configparser.ConfigParser(interpolation=configparser.ExtendedInterpolation())config.read('test_pyconfig.ini')sections = config.sections()print(sections)print(config['MoreAdvanceUsage'].get('my_library')) Comment与parser冲突问题说明,value中包含#在行内是okay的,但是如果出现在开头就会被视为comment,所以可以使用DEFAULTSECT中定义好#,然后在其他sections中用引号引用即可.1234567891011121314151617181920212223242526272829303132333435363738&gt;&gt;&gt; from configparser import ConfigParser, ExtendedInterpolation&gt;&gt;&gt; parser = ConfigParser(interpolation=ExtendedInterpolation())&gt;&gt;&gt; # the default BasicInterpolation could be used as well&gt;&gt;&gt; parser.read_string("""... [DEFAULT]... hash = #...... [hashes]... shebang =... $&#123;hash&#125;!/usr/bin/env python... $&#123;hash&#125; -*- coding: utf-8 -*-...... extensions =... enabled_extension... another_extension... #disabled_by_comment... yet_another_extension...... interpolation not necessary = if # is not at line start... even in multiline values = line #1... line #2... line #3... """)&gt;&gt;&gt; print(parser['hashes']['shebang'])#!/usr/bin/env python# -*- coding: utf-8 -*-&gt;&gt;&gt; print(parser['hashes']['extensions'])enabled_extensionanother_extensionyet_another_extension&gt;&gt;&gt; print(parser['hashes']['interpolation not necessary'])if # is not at line start&gt;&gt;&gt; print(parser['hashes']['even in multiline values'])line #1line #2line #3 自定义boolean使用.getboolean方法可以获取到key对应的boolean值,默认支持True: ‘1’, ‘yes’, ‘true’, ‘on’False: ‘0’, ‘no’, ‘false’, ‘off’也可以自己配置configparser.BOOLEAN_STATES配置12345678910&gt;&gt;&gt; custom = configparser.ConfigParser()&gt;&gt;&gt; custom['section1'] = &#123;'funky': 'nope'&#125;&gt;&gt;&gt; custom['section1'].getboolean('funky')Traceback (most recent call last):...ValueError: Not a boolean: nope# 自己定义&gt;&gt;&gt; custom.BOOLEAN_STATES = &#123;'sure': True, 'nope': False&#125;&gt;&gt;&gt; custom['section1'].getboolean('funky')False value需要大写方案默认获取到的value是小写的,如果一定需要大写,就需要重写configparser.optionxform1234567891011121314151617181920&gt;&gt;&gt; config = """... [Section1]... Key = Value...... [Section2]... AnotherKey = Value... """&gt;&gt;&gt; typical = configparser.ConfigParser()&gt;&gt;&gt; typical.read_string(config)&gt;&gt;&gt; list(typical['Section1'].keys())['key']&gt;&gt;&gt; list(typical['Section2'].keys())['anotherkey']&gt;&gt;&gt; custom = configparser.RawConfigParser()&gt;&gt;&gt; custom.optionxform = lambda option: option&gt;&gt;&gt; custom.read_string(config)&gt;&gt;&gt; list(custom['Section1'].keys())['Key']&gt;&gt;&gt; list(custom['Section2'].keys())['AnotherKey'] re(正则匹配)参考官方API文档. re.compile_编译语法1re.compile(pattern, flags=0)说明会先把正则表达式进行编译, pattern为正则表达式, flages能够操控匹配的模式.例如:12prog = re.compile(pattern)result = prog.match(string)相当于:1result = re.match(pattern, string)常用flages:re.I或re.IGNORECASE: 不区分大小写. 连[A-Z]也同时可以匹配小写字母.re.M或re.MULTILINE: ^和$可以覆盖到多行.re.S或re.DOTALL: .可以匹配包括换行符在内的的所有内容.re.X或re.VERBOSE: 允许使用更加易读的方式书写表达式.空白字符会被忽略, 同时还可以进行注释, 见例子1.例子11234a = re.compile(r"""\d + # the integral part \. # the decimal point \d * # some fractional digits""", re.X)b = re.compile(r"\d+\.\d*") PyYAML基本用法请参考:官方文档.这里主要列出一些技巧. 输出的style列出dump能够使用的参数:default_style=None,default_flow_style=None, # (bool)flow风格开关canonical=None, # (bool)是否显示数据类型标签indent=None, # (int)缩进width=None, # (int)宽度allow_unicode=None, # (bool)是否允许unicode编码line_break=None, # 指定换行的特殊字符encoding=None, # 编码类型explicit_start=None, # suffixexplicit_end=None, # preffixversion=None,tags=None默认情况下, dump出来的yaml数据使用的是流式(flow)风格, 也那就是下面的情况:123print(yaml.dump([i for i in range(5)]))# out:[0, 1, 2, 3, 4]可通过改变参数实现块式(block)风格输出, 更经典.1234567print(yaml.dump([i for i in range(5)], default_flow_style=False))# out:- 0- 1- 2- 3- 4带数据格式tag的输出12345678910print(yaml.dump([i for i in range(5)], canonical=True))# out:---!!seq [ !!int "0", !!int "1", !!int "2", !!int "3", !!int "4",] Yaml特殊格式多合一12345678910111213141516171819202122232425&gt;&gt;&gt; dat = """... ---... - Ada... - APL... - ASP...... - Assembly... - Awk... ---... - Basic... ---... - C... - C# # 如果需要使用注释, 使用'C #'而不是'C#'.... - C++... - Cold Fusion... """# 使用load_all不能直接输出, 需要遍历&gt;&gt;&gt; yaml.load_all(dat)&lt;generator object load_all at 0x104a44fc0&gt;&gt;&gt;&gt; for data in yaml.load_all(dat):... print(data)...['Ada', 'APL', 'ASP', 'Assembly', 'Awk']['Basic']['C', 'C#', 'C++', 'Cold Fusion']list列表的嵌套123456789101112131415# YAML- - HTML - LaTeX - SGML - VRML - XML - YAML- - BSD - GNU Hurd - Linux# Python[['HTML', 'LaTeX', 'SGML', 'VRML', 'XML', 'YAML'], ['BSD', 'GNU Hurd', 'Linux']]嵌套之前使用’-‘或’ '不重要, 重要的是要保持缩进123456789# YAML- 1.1- - 2.1 - 2.2- - - 3.1 - 3.2 - 3.3# Python[1.1, [2.1, 2.2], [[3.1, 3.2, 3.3]]]字典与列表的嵌套123456789101112# YAMLleft hand:- Ring of Teleportation- Ring of Speedright hand:- Ring of Resist Fire- Ring of Resist Cold- Ring of Resist Poison# Python&#123;'right hand': ['Ring of Resist Fire', 'Ring of Resist Cold', 'Ring of Resist Poison'],'left hand': ['Ring of Teleportation', 'Ring of Speed']&#125;列表中嵌套字典123456789101112# YAML- name: PyYAML status: 4 license: MIT language: Python- name: PySyck status: 5 license: BSD language: Python# Python[&#123;'status': 4, 'language': 'Python', 'name': 'PyYAML', 'license': 'MIT'&#125;,&#123;'status': 5, 'license': 'BSD', 'name': 'PySyck', 'language': 'Python'&#125;]允许key中包含’ ‘, 并且可是使用’?‘和’:'分两行显示key:value12345678910# YAMLbase armor class: 0# Python&#123;'base armor class': 0&#125;# YAML? key: value# Python&#123;'key': 'value'&#125;5种value的表示方法, 分别是plain, single-quoted, double-quoted, literal, 以及 folded:123456789101112131415# YAMLplain: Scroll of Remove Cursesingle-quoted: &apos;EASY_KNOW&apos;double-quoted: &quot;?&quot;literal: | # Borrowed from http://www.kersbergen.com/flump/religion.html by hjw ___ __ /.-.\ / )_____________\\ Y /_ /=== == === === =\ _\_ ( /)=== == === === == Y \ `-------------------( o ) \___/folded: &gt; It removes all ordinary curses from all equipped items. Heavy or permanent curses are unaffected.别名,其实感觉就是yaml中的变量123456789101112131415161718192021222324252627# YAMLHost: - &amp;foo bar - *foo - *foo# Python&#123;&apos;Host&apos;: [&apos;bar&apos;, &apos;bar&apos;, &apos;bar&apos;]&#125;# YAMLleft hand: &amp;A name: The Bastard Sword of Eowyn weight: 30right hand: *A# Python&#123; &quot;left hand&quot;: &#123; &quot;name&quot;: &quot;The Bastard Sword of Eowyn&quot;, &quot;weight&quot;: 30 &#125;, &quot;right hand&quot;: &#123; &quot;name&quot;: &quot;The Bastard Sword of Eowyn&quot;, &quot;weight&quot;: 30 &#125;&#125;标签tag, 更多可见yaml标签表12345678910111213141516171819# YAMLboolean: !!bool &quot;true&quot;integer: !!int &quot;3&quot;float: !!float &quot;3.14&quot;# Python&#123;&apos;boolean&apos;: True, &apos;integer&apos;: 3, &apos;float&apos;: 3.14&#125;# 可通过修改标签改变数据格式boolean: !!str &quot;true&quot;integer: !!int &quot;3&quot;float: !!float &quot;3.14&quot;# Python&#123; &quot;boolean&quot;: &quot;true&quot;, &quot;integer&quot;: 3, &quot;float&quot;: 3.14&#125;yaml下的tag与python数据类型对比表如下: time(操作时间数据) XMind 一图读懂下载链接(密码:cd8c) 声明版权： 2018-now，🇨🇳，zangjiaao&lt;zangjiaao@yahoo.com&gt;由家浩创作并维护的zangjiaao's blog博客所有文章除特别声明外，均采用&quot;署名-非商业性使用-相同方式共享4.0(CC BY-NC-SA 4.0)国际许可证&quot;。本文首发于zangjiaao’s blog博客，转载请注明出处。]]></content>
      <categories>
        <category>04_学习笔记</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell编程速查]]></title>
    <url>%2F2018%2F06%2F12%2FShell%E7%BC%96%E7%A8%8B%E9%80%9F%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[概述： 学习老男孩shell编程的一些笔记吧，python和shell必须要会啊！加油… 😋 Shell编程速查TODO环境变量设置、使用、取消引号使用规则awk特殊规则特殊变量crontabsed声明 TODOUbuntu学习——第一篇 - R_e - 博客园sed命令_Linux sed 命令用法详解：功能强大的流式文本编辑器 环境变量 设置、使用、取消export: 设置变量env: 显示当前所有变量echo $PATH: 显示PATH变量的值，前面加$echo ${PATH}: 同上unset: 取消设置变量 引号使用规则' ': 单引号包裹内容，所见即所得，不会执行其中的命令&quot; &quot;: 双引号中的变量和反引号内容会被执行。例如echo &quot;$PATH&quot;会显示PATH变量，而echo '$PATH'则不会sed与grep都遵循以上规则，但是awk比较特殊，如下： awk特殊规则但是，在awk中的定义正好相反，例如：12345678910111213TEST_ME=123awk 'BEGIN &#123;print '$TEST_ME'&#125;' 123awk 'BEGIN &#123;print "$TEST_ME"&#125;' $TEST_MEawk 'BEGIN &#123;print $TEST_ME&#125;' awk: illegal field $(), name "TEST_ME" source line number 1# 两个比较特殊的情况awk 'BEGIN &#123;print '"$TEST_ME"'&#125;' 123awk 'BGGIN &#123;print "'$TEST_ME'"&#125;' 123因此一半的做法是使用echo然后管道给awk，例如：1234567TEST_ME=123echo "$TEST_ME"|awk '&#123;print $0&#125;' 123echo '$TEST_ME'|awk '&#123;print $0&#125;' $TEST_MEecho $TEST_ME|awk '&#123;print $0&#125;' 123 特殊变量$0: 当前执行shell脚本的文件名，包含路径则是路径$n: 代表第n个参数，支持$1..9，大于9需要用${10}表示$#: 代表参数总数量$*: 代表所有参数，&quot;$*&quot;相当于$1 $2 ..$@: 代表所有参数（因此不加引号同$*），&quot;$@&quot;相当于&quot;$1&quot;,&quot;$2&quot;.. crontabFrom: Ubuntu学习_博客园-u user：用来设定某个用户的crontab服务；-e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。-l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。-r：从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。-i：在删除用户的crontab文件时给确认提示123456789* * * * * command to be executed- - - - - -| | | | | || | | | | --- 预执行的命令| | | | ----- 表示星期0～7（其中星期天可以用0或7表示）| | | ------- 表示月份1～12| | --------- 表示日期1～31| ----------- 表示小时1～23（0表示0点）------------- 表示分钟1～59 每分钟用*或者 */1表示 sed1sed [-nefr] [动作] [文件]选项与参数:-n：使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN 的数据一般都会被列出到终端上。但如果加上 -n 参数后，则只有经过sed 特殊处理的那一行(或者动作)才会被列出来-e：直接在命令列模式上进行 sed 的动作编辑-f：直接将 sed 的动作写在一个文件内， -f filename 则可以运行 filename 内的 sed 动作-r：sed 的动作支持的是延伸型正规表示法的语法。(默认是基础正规表示法语法)-i：直接修改读取的文件内容，而不是输出到终端。动作:[n1[,n2]] (动作): 表示指定修改的行范围, 从n1到n2, 为空表示全文范围;a: 新增, a的后面可以接字串，而这些字串会在新的一行出现(目前的下一行);c: 替换, c的后面可以接字串，这些字串可以取代 n1,n2 之间的行;d: 删除, 因为是删除啊，所以 d 后面通常不接任何咚咚；i: 插入,范例:使用下面的命令创建了测试样本:1for i in &#123;1..10&#125;;do touch i.txt; echo "$i" &gt;&gt; i.txt;done;删除实例:12345678910111213# 删除单行sed -e &quot;1d&quot; i.txt# 删除单行(正则方式)sed -e &quot;/4/d&quot; i.txt # 删除包含4的行# 删除多行sed -e &quot;1,3d&quot; i.txt # 删除1至3行sed -e &quot;1d;3d;5d&quot; i.txt # 删除1,3,5行# 删除多行(正则方式)sed -e &quot;/4/,/8/d&quot; i.txt # 删除从包含4的行到包含8的行(包含自己)sed -e &quot;1,/8/d&quot; i.txt # 删除从第一行开始到第一个包含8的行 声明版权： 2018-now，🇨🇳，zangjiaao&lt;zangjiaao@yahoo.com&gt;由家浩创作并维护的zangjiaao's blog博客所有文章除特别声明外，均采用&quot;创作共用保留署名-非商业-禁止演绎4.0国际许可证&quot;。本文首发于zangjiaao’s blog博客，转载请注明出处。]]></content>
      <categories>
        <category>03_工具手册</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kali使用技巧]]></title>
    <url>%2F2018%2F06%2F11%2FKali%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[概述： 用于记录一些日常实用kali的一些磕磕绊绊，毕竟不能在一块石头上栽好几跟头吧… 😂 Kali使用技巧安装 OpenVAS启动停止管理用户安装 chrome以root身份运行chrome解决打开时弹“输入密码以解锁您的登录密钥环”问题安装 proxychains+shadowsocks安装 VMware ToolsMetasploit 自动连接 postgresql系统更新失败解决办法声明 安装 OpenVAS参考：Configuring and Tuning OpenVAS in Kali Linux 、OpenVAS 8.0 Vulnerability Scanning、 openVAS 官网。使用下面方法进行安装：12345root@kali:~# apt-get updateroot@kali:~# apt-get dist-upgraderoot@kali:~# apt-get install openvasroot@kali:~# openvas-setup 启动停止12345678910# 启动root@kali:~# openvas-startStarting OpenVas ServicesStarting Greenbone Security Assistant: gsad.Starting OpenVAS Scanner: openvassd.Starting OpenVAS Manager: openvasmd.# 停止root@kali:~# openvas-stopStopping OpenVas Services 管理用户运行openvasmd –-create-user用于添加新用户：12345root@kali:~# openvasmd --create-user=dookieUser created with password 'yyyyyyyy-yyyy-yyyy-yyyy-yyyyyyyyyy'.root@kali:~# openvasmd --get-usersadmindookie修改密码：12root@kali:~# openvasmd --user=dookie --new-password=s3cr3troot@kali:~# openvasmd --user=admin --new-password=sup3rs3cr3t 安装 chrome由于沙箱的缘故，kali 使用 chrome 需要使用 root 方式，这样就处罚了 chrome 的安全机制，需要添加参数。安装步骤只需要进行以下几步：打开 chrome 网站，下载到.deb 安装文件；进入到下载目录，执行dpkg --install xxx.deb进行安装；安装过程依赖问题报错需要使用apt-get -f install进行修复；修复完成以后，再运行安装命令即可安装。 以root身份运行chrome直接在桌面使用 root 打开 chrome 是没有反应的，因为出发了保护机制。官方说要追加--no-sandbox参数才能继续（我直接使用绝对路径/opt/goole/chrome/google-chrome打开时通过错误信息才发现的。），需要进行以下操作：使用任意文本编辑器打开文件/opt/goole/chrome/google-chrome，定位到最下方看到诸如以下内容:12# Note: exec -a below is a bashism.exec -a &quot;$0&quot; &quot;$HERE/chrome&quot; &quot;$@&quot;这里只需要修改为以下内容即可：12# Note: exec -a below is a bashism.exec -a &quot;$0&quot; &quot;$HERE/chrome&quot; &quot;$@&quot; --no-sandbox保存后重新打开即可。 解决打开时弹“输入密码以解锁您的登录密钥环”问题这个问题简直是莫名其妙，输入 root 密码居然说不对…使用如下方法解决：首先在终端输入seahorse打开“密码与密钥”（如果命令不存在使用apt-get install seahores安装即可）;首先删除默认的“密码”下的“Login”或者“登录”，右键点击里面就有删除；删除完后退出，重新打开 chrome，还会弹窗，直接输入两个回车（也就是都为空）。会提示“以不加密方式存储密码吗？”，直接“继续”即可。 安装 proxychains+shadowsocks主要为了挂代理干大事，更新啊啥的还是用 proxychains 快点。Kali 原生其实带 3.x 的 proxychains 的，但是版本太低不支持新版 apt 工具，所以需要改成 proxychains-ng 也就是 4.0。step1. 首先需要删除 Kali 原生的 proxychains，使用apt-get remove proxychains删除。step2. 进入Github 地址下载安装，官方文档介绍安装方法很清楚了，使用编译的方法安装即可：1234567891011*** Installation *** git clone https://github.com/rofl0r/proxychains-ng.git cd proxychains-ng # needs a working C compiler, preferably gcc ./configure --prefix=/usr --sysconfdir=/etc make [optional] sudo make install [optional] sudo make install-config (installs proxychains.conf) # if you dont install, you can use proxychains from the build directory like this: ./proxychains4 -f src/proxychains.conf telnet google.com 80step3.  接下来进入pip-shadowsocks安装 ss：12345678# Install# Debian / Ubuntu:apt-get install python-pippip install shadowsocks# CentOS:yum install python-setuptools &amp;&amp; easy_install pippip install shadowsocksstep4. 添加配置文件：123456789101112// /etc/shadowsocks.json&#123; "server":"207.148.26.251", "server_port":543, "local_port":1080, "password":"z4931568", "timeout":600, "method":"aes-256-cfb"&#125;// /root/start-shadosocks.shsslocal -c /etc/shadowsocks.json -d startstep5. 启动时候会报错“loading libcrypto from libcrypto.so.1.1”的错误，这个问题是由于在 openssl1.1.0 版本中，废弃了 EVP_CIPHER_CTX_cleanup 函数。按照下面的方法调整一下：vim /usr/local/lib/python2.7/dist-packages/shadowsocks/crypto/openssl.py (该路径请根据自己的系统情况自行修改，如果不知道该文件在哪里的话，可以使用 find 命令查找文件位置)；在 vim 中输入:%s/cleanup/reset/g保存并退出step6. 修改/etc/proxychains.conf，最后一行换成socks5 127.0.0.1 1080即可完成安装。 安装 VMware Tools参考官方文档。12345apt update &amp;&amp; apt -y full-upgrade# Reboot now in case you have updated to a new kernel. Once rebooted:apt -y --reinstall install open-vm-tools-desktop fusereboot安装完成后还需要在查看-》自动调整大小中勾选“自动适应客户机”和“自动适应窗口” Metasploit 自动连接 postgresql简述： Kali 自带的 Metasploit 与 ppstgresql 不会自动连接，时常出现&quot;[-] Database not connected&quot;的问题，为了解决这个问题需要让这俩自动连接。其他内容可参考这边文章。1、使 Postgresql 自启动script12345678910111213141516171819202122systemctl status postgresql Active: inactive (dead)systemctl enable postgresql Executing: /lib/systemd/systemd-sysv-install enable postgresqlsystemctl start postgresqlmsfdb init [i] Database already started [+] Creating database user 'msf' 为新角色输入的口令: 再输入一遍: [+] Creating databases 'msf' [+] Creating databases 'msf_test' [+] Creating configuration file '/usr/share/metasploit-framework/config/database.yml' [+] Creating initial database schemamsfconsolemsf &gt; db_status [*] postgresql connected to msf 系统更新失败解决办法参考：Kali Linux 更新失败。报错中可以看出是由于密钥过期。首先使用查看系统里所有的密钥信息：1apt-key list通过输出结果的最后一行就是导致这次问题的公钥，到期时间是 2018 年 2 月 2 日（有效期大约是 6 年）。具体更新方法有以下几种方法：（任选一种即可）123456789101112131、apt-key adv --keyserver keys.gnupg.net --recv-keys ED444FF07D8D0BF62、wget -q -O - archive.kali.org/archive-key.asc | apt-key add3、gpg --keyserver hkp://pgpkeys.mit.edu --recv-key ED444FF07D8D0BF6gpg -a --export ED444FF07D8D0BF6 | sudo apt-key add -4、wget https://http.kali.org/kali/pool/main/k/kali-archive-keyring/kali-archive-keyring_2018.1_all.debapt install ./kali-archive-keyring_2018.1_all.deb 声明版权： 2018-now，🇨🇳，zangjiaao&lt;zangjiaao@yahoo.com&gt;由家浩创作并维护的zangjiaao's blog博客所有文章除特别声明外，均采用&quot;署名-非商业性使用-相同方式共享4.0(CC BY-NC-SA 4.0)国际许可证&quot;。本文首发于zangjiaao’s blog博客，转载请注明出处。]]></content>
      <categories>
        <category>03_工具手册</category>
      </categories>
      <tags>
        <tag>kali</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cmder美化与增强]]></title>
    <url>%2F2018%2F06%2F10%2FCmder%E7%BE%8E%E5%8C%96%E4%B8%8E%E5%A2%9E%E5%BC%BA%2F</url>
    <content type="text"><![CDATA[概述： 主要介绍了一些cmder的美化操作，以及其中继承的git小插件… Cmder 配置安装 Chocolatey 包管理安装 Cmder方法 a：Chocolatey方法 b：官网下载 full 版本安装 Powerline 字体安装 Posh-Git 及 Oh-My-Posh安装 Get-ChildItemColor配置 PowerShell 的$PROFILE声明效果图： 安装 Chocolatey 包管理参考： Pimping Up Your PowerShell &amp; Cmder with Posh-Git, Oh-My-Posh, &amp; Powerline Fonts使用管理员身份打开 Powershell，执行下面的命令修改执行权限：1Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Force这里 PS 可能会报错，权限除了RemoteSigned还可以改为ByPass、Unrestricted，执行Get-ExecutionPolicy检查当前状态。随后使用下面命令安装 chocolatey：1iwr https://chocolatey.org/install.ps1 -UseBasicParsing | iex 安装 Cmder 方法 a：Chocolatey执行下面命令进行安装：1cinst cmder -y这个方法貌似不带 git 等工具，还需要单独安装，我选择方法 b 安装。 方法 b：官网下载 full 版本直接去官网下载。 安装 Powerline 字体运行下面命令：123git clone https://github.com/powerline/fonts.gitcd fonts.\install.ps1但是这个方法安装的是所有字体，比较慢也没有必要，只需要安装这个字体即可。 安装 Posh-Git 及 Oh-My-Posh简介： Posh-Git (PowerShell Git) 主要用于当你进入一个包含 git 项目时，显示项目信息。Oh-My-Posh 则主要用于定义 Posh-Git 的主题。运行下面的命令安装Posh-Git：123Install-PackageProvider NuGet -MinimumVersion '2.8.5.201' -ForceSet-PSRepository -Name PSGallery -InstallationPolicy TrustedInstall-Module -Name 'posh-git'运行下面的命令安装Oh-My-Posh:1Install-Module -Name 'oh-my-posh'可以前往oh-my-posh预览主题。 安装 Get-ChildItemColor简介： 主要用于定义列目录风格，Get-ChildItemColor是传统 PS 风格，Get-ChildItemColorFormatWide是类 Unix 风格，下面配置文件里面也会映射l及ls来替代。运行下面的命令进行安装：1Install-Module -Name 'Get-ChildItemColor' 配置 PowerShell 的$PROFILE这里默认的$PROFILE 是C:\Users\18354\Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1，如果修改这个文件会联动到 Powershell，但是我比较习惯只修改 cmder 的配置文件%CMDER_ROOT%\vendor\profile.ps1，只需要在最后追加下面内容即可：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# Ensure that Get-ChildItemColor is loadedImport-Module Get-ChildItemColor# Set l and ls alias to use the new Get-ChildItemColor cmdletsSet-Alias l Get-ChildItemColor -Option AllScopeSet-Alias ls Get-ChildItemColorFormatWide -Option AllScope# Helper function to change directory to my development workspace# Change c:\ws to your usual workspace and everytime you type# in cws from PowerShell it will take you directly there.function cws &#123; Set-Location c:\ws &#125;# Helper function to set location to the User Profile directoryfunction cuserprofile &#123; Set-Location ~ &#125;Set-Alias ~ cuserprofile -Option AllScope# Helper function to show Unicode characterfunction U&#123; param ( [int] $Code ) if ((0 -le $Code) -and ($Code -le 0xFFFF)) &#123; return [char] $Code &#125; if ((0x10000 -le $Code) -and ($Code -le 0x10FFFF)) &#123; return [char]::ConvertFromUtf32($Code) &#125; throw "Invalid character code $Code"&#125;# Ensure posh-git is loadedImport-Module -Name posh-git# Start SshAgent if not already# Need this if you are using github as your remote git repositoryif (! (ps | ? &#123; $_.Name -eq 'ssh-agent'&#125;)) &#123; Start-SshAgent&#125;# Ensure oh-my-posh is loadedImport-Module -Name oh-my-posh# Default the prompt to agnoster oh-my-posh themeSet-Theme agnoster 声明版权： 2018-now，🇨🇳，zangjiaao&lt;zangjiaao@yahoo.com&gt;由家浩创作并维护的zangjiaao's blog博客所有文章除特别声明外，均采用&quot;署名-非商业性使用-相同方式共享4.0(CC BY-NC-SA 4.0)国际许可证&quot;。本文首发于zangjiaao’s blog博客，转载请注明出处。]]></content>
      <categories>
        <category>05_日常折腾</category>
      </categories>
      <tags>
        <tag>cmder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebGoat项目搭建]]></title>
    <url>%2F2018%2F06%2F10%2FWebGoat%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[概述： 记录Webgoat项目的搭建过程。包括用maven构建；用jenkins(还没有开始写…)进行自动化部署、测试；源码审计的一些记录…(TODO…) WebGoat项目搭建简介准备部署WebGoat项目声明 简介本次操作在mac下进行。主要是为了源码方式运行WebGoat/WebGoat，然后学习java代码审计。 准备jdk安装: 官网下载jdk8。然后配置环境变量，写到/etc/profile里。1export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_171.jdk/Contents/Homemaven安装: 官网下载二进制包。建议解压到/usr/local/apache-maven中。然后配置环境变量，写到/etc/profile里。随后使用mvn -version查看一下版本。1234export M2_HOME=/usr/local/apache-maven/apache-maven-3.5.3export M2=$M2_HOME/binexport MAVEN_OPTS="-Xms256m -Xmx512m"export PATH=$M2:$PATH 部署WebGoat项目依据官网文档中的方法。下载源码:1git clone git@github.com:WebGoat/WebGoat.git部署:12cd WebGoatmvn clean installmvn编译到xxe时候会报错，提示maven-surefire-plugin的There are test failures错误(参考)，需要在pom.xml文件中build节点下plugins节点中下添加下面内容：1234567&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;testFailureIgnore&gt;true&lt;/testFailureIgnore&gt; &lt;/configuration&gt;&lt;/plugin&gt;运行:WebGoat使用Spring-boot启动：1234# 运行webgoat-servermvn -pl webgoat-server spring-boot:run# 运行webwolf，注意这里的目录也是 WebGoat/mvn -pl webwolf spring-boot:runwebgoat访问地址:1http://localhost:8080/WebGoatwebwolf访问地址:1http://127.0.0.1:8081/login📖 说明： mvn参数：-am, --alsomake: 同时构建所列模块的依赖模块模块；-amd, --also-make-dependents: 同时构建依赖于所列模块的模块；-pl, --projects&lt;arg&gt;: 构建指定模块，模块间用逗号分割；-rf, -resume-from&lt;arg&gt;: 从指定的模块回复反应堆。IDEA联动: IDEA默认自带maven环境，不想用那个的话可以在IDEA中的终端，可以在设置中搜索maven更改环境路径。 声明版权： 2018-now，🇨🇳，zangjiaao&lt;zangjiaao@yahoo.com&gt;由家浩创作并维护的zangjiaao's blog博客所有文章除特别声明外，均采用&quot;署名-非商业性使用-相同方式共享4.0(CC BY-NC-SA 4.0)国际许可证&quot;。本文首发于zangjiaao’s blog博客，转载请注明出处。]]></content>
      <categories>
        <category>02_环境搭建</category>
      </categories>
      <tags>
        <tag>WebGoat</tag>
        <tag>DevOps</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim使用技巧]]></title>
    <url>%2F2018%2F06%2F09%2FVim%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[概述： 为了方便查找记忆，只记录一些感觉比较实用技巧，基础操作还请自行搜索… vim使用技巧技巧* Tips001:数字快捷加减* Tips002:快捷删除、修改* Tips005:快捷新旧位置跳转* Tips006:上一步与取消上一步* Tips009:替换、转换* Tips010:查找* Tips011:缩进* Tips012:保存、读取Tips003:模式切换Tips004:显示文件信息Tips007:剪贴板Tips008:插入特殊编码字符配置* 搜索、高亮命令补全窗口切换* 告警静音声明 技巧 * Tips001:数字快捷加减&lt;C-a&gt;: 对数字进行加操作。&lt;C-x&gt;: 对数字进行减操作。💡 技巧： 连在一起的数字被视为一个数字。可以使用{number}&lt;C-a&gt;或者{number}&lt;C-x&gt;进行计算，可配合.进行操作。 * Tips002:快捷删除、修改i_&lt;C-w&gt;: 删除前一个单词。i_&lt;C-h&gt;: 删除前一个字符。i_&lt;C-u&gt;: 删至行首。ce: 从光标删除到词尾，并进入插入模式。c$：从光标删除到行尾，并进入插入模式。cw：从光标删除到下一个单词词首，并进入插入模式。C: 等同于c$。D：删除从光标到结尾的内容，同d$。R: 进入替换模式，按&lt;ESC&gt;键退出。 * Tips005:快捷新旧位置跳转&lt;C-O&gt;: 跳转回旧位置。&lt;C-I&gt;: 跳转到新位置。 * Tips006:上一步与取消上一步&lt;C-R&gt;: 回到撤销前状态。 * Tips009:替换、转换~：转换一个字母大小写。{num}~：转换指定数量的字母大小写。g~~：转换当前一行字母大小写。sv_U | v_u：view模式下，转换大小写。gUU | guu：将一行全部转至大写活或者小写。{num}gUU：将指定数量的行进行转换。gUw | guw：将光标下的单词转换。:s/old/new: 行内一次替换。:s/old/new/g: 行内全部替换。:{line_num1},{line_num2}s/old/new/g: 多行替换。:%s/old/new/g: 全文替换。:%s/old/new/gc: 每次替换进行询问。💡 技巧： View模式下，可以在选中区域里替换。 * Tips010:查找\: 正向查找。?: 反向查找。 * Tips011:缩进&gt;G: 让下面的内容缩进。💡 技巧： View模式下，可以将选中区域进行缩进。 * Tips012:保存、读取:w FILENAME: 保存并命名，重复使用会新建文件。v_:w FILENAME: 可将选中部分保存到文件。:r FILENAME: 可提取磁盘文件，将其插入到当前文件的光标位置。:r !dir: 可以读取 dir 命令的输出并将其放置到当前文件的光标位置后面。 Tips003:模式切换&lt;C-[&gt;: 切换到普通模式，不过习惯&lt;ESC&gt;退出了。&lt;C-o&gt;: 临时切换插入-普通模式。 Tips004:显示文件信息&lt;C-G&gt;: 显示当前光标所在位置和文件状态信息。 Tips007:剪贴板i_&lt;C-p&gt;: 显示寄存器列表，但是只能在VIM中使用。 Tips008:插入特殊编码字符i_&lt;C-v&gt;: 插入模式下，用来使用ASCII或UNICOD码插入某个特殊字符。 配置输入 :set xxx 可以设置 xxx 选项。一些有用的选项如下： * 搜索、高亮ic | ignorecase：查找时忽略字母大小写。is | incsearch：查找短语时显示部分匹配。hls | hlsearch：高亮显示所有的匹配短语。 命令补全&lt;C-D&gt;: 查看可能的补全结果。&lt;TAB&gt;: 可以使用一个补全。 窗口切换CTRL-W CTRL-W: 切换窗口（注意是两次）。 * 告警静音vb | visualbell：屏幕的闪烁代替bell。noeb | noerrorbells：输入出错不响bell。 声明版权： 2018-now，🇨🇳，zangjiaao&lt;zangjiaao@yahoo.com&gt;由家浩创作并维护的zangjiaao's blog博客所有文章除特别声明外，均采用&quot;署名-非商业性使用-相同方式共享4.0(CC BY-NC-SA 4.0)国际许可证&quot;。本文首发于zangjiaao’s blog博客，转载请注明出处。]]></content>
      <categories>
        <category>03_工具手册</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>速查</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexoblog部署记录]]></title>
    <url>%2F2018%2F06%2F09%2FHexoblog%E9%83%A8%E7%BD%B2%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[概述： 记录我是如何搭建这个&quot;快速、简洁且高效的博客框架Hexo&quot;的… Hexo博客部署环境搭建依赖安装初始化更新修改主题NexThexo-theme-apollo建立Github项目将源文件托管到Github更新项目配置&amp;说明配置文件说明命令行说明基本配置添加分类 &amp; 标签添加头像添加显示当前进度配置首页只显示简介添加资源目录压缩静态资源压缩静态资源-使用gulp部署到GitHub让文章依据updatedp排序支持checkbox功能拓展（推荐）markdown-it-plus 插件（不推荐）emoji支持（不推荐）hexo-TOCemoji速查表404页面搜索（本地）搜索（algolia）创建文章时自动打开VSCode添加评论功能添加页面载入进度条其他功能声明 环境搭建 依赖安装Git安装Node.js可参考官方文档。 安装只需要使用npm安装hexo，默认带server了：1npm install -g hexo-cli 初始化刚才安装的那些只是hexo的部署环境以及管理命令，以下才是真正的“建站”，初始化/创建站点文件。12cd hexo_bloghexo init📖 说明：官方文档中还有一步npm install，实际在init时候就做好了。 更新更新hexo，只需npm即可。12cd hexo_bloghexo update 修改主题 NexT⚠️ 注意： 如果需要将整个项目托管到Github，可以暂时忽略本节内容。简介请移步官网，传送门。安装:12cd hexo_bloggit clone https://github.com/theme-next/hexo-theme-next themes/next更新:12cd themes/nextgit pull启用: 修改 站点 的_config.yml文件1theme: next hexo-theme-apollo样子也非常小清新,官方传送门. 建立Github项目为了防止辛苦写出来的文章不翼而飞，同时也想用GitHub把源码维护起来，因此将源文件托管到Github。参考Tips for Hexo configuration大神文章。 将源文件托管到Githubfork Next点右上角的fork即可。初始化blog为git项目12cd hexo_bloggit init创建分支（本地），并切换123456789git checkout -b source# 查看是不是进入了source分支git branch master *source# 如果创建错了，可以删除git branch -D bad_branch# 也可以重命名git branch -m bad_branch good_branch将之前fork的next添加到submodule123456789101112131415# 下面的操作会吧themes/next路径添加到submodules中# 并且识别如果目录不存在会自动clonepwd hexo_blog/git submodule add git@github.com:billxllid/next.git themes/next# 添加错了可以删除，不过方法需要自行查找，并不难# 创建自己的next分支，名字随便设置cd themes/nextgit checkout -b zangjiaao# 然后可以随便修改主题配置什么的# 上传分支git add .git commit -m "change configs"# 刚才设置的分支是什么这就是什么git push origin zangjiaao上传到分支（远端）123456789pwd hexo_blog/git add .git commit -m "Initial"git remote add origin# 添加远端仓库地址git@github.com:billxllid/blog.zangjiaao.cn.git# push分支到远端git push origin source 更新项目更新next1234# 新环境才需要initgit submodule init# 正常update即可git submodule update直接更新master分支，而后merge到自己的分支上。123456789101112131415161718pwd themes/nextgit branch *master zangjiaaogit remote add upstream https://github.com/theme-next/hexo-theme-next.gitgit remote -v origin https://github.com/billxllid/next.git (fetch) origin https://github.com/billxllid/next.git (push) upstream https://github.com/theme-next/hexo-theme-next.git (fetch) upstream https://github.com/theme-next/hexo-theme-next.git (push)# 查看master有没有更新git fetch upstream# 可以直接更新远端git pull upstream master# 或者先merge到本地，再push到远端git merge upstream/mastergit push💡 技巧： 可以到自己next项目的自己的分支创建pull来对比一下upstream，看哪里有修改。 配置&amp;说明 配置文件说明_config.yml 站点主要配置文件。package.json hexo所使用的组件信息。scaffolds/ 模板目录。source/ 资源目录，包含原始文章.md以及解析后文章（保存在public目录下）。 命令行说明hexo init 初始化站点文件hexo new [layout] &lt;title&gt; 按照模板layout创建posthexo (g)enerate 生成静态文件-d 创建完后部署（上传到git）-w 检查文件变动hexo server 启动服务器-p 指定端口给-s 只使用静态文件-l 记录日志hexo deploy 部署（上传到git）-g 部署前生成静态文件hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)💡 提醒： 每次修改 站点 _config.yml 文件后由于hexo的缓存问题需要刷新。一种办法是hexo g重新生成，好处是不用重启Server；另一种方法是hexo clean &amp; hexo server，这种我认为更彻底，不过比较麻烦就是。更多详见 指令 。 基本配置简单修改（标题、语言、时区）12345678# Sitetitle: zangjiaao&apos;s blogsubtitle: 滴水穿石...description: 纸上得来终觉浅...keywords:author: jiahaolanguage: zh-CNtimezone: Asia/Shanghai更多详见 官方文档 。 添加分类 &amp; 标签创建:12345# 分类hexo new page categories# 标签hexo new page tags编辑: 在index.md中添加以下内容12345678910111213# 分类---title: categoriesdate: 2018-05-06 00:57:48type: &quot;categories&quot;---# 标签---title: tagsdate: 2018-05-06 00:57:48type: &quot;tags&quot;--- 添加头像配置: 在 主题 的_config.yml中查找avatar并编辑为下面的内容，随后上传头像文件至 站点 的uploads并重命名为avatar.gif。1avatar: /uploads/avatar.gif📖 说明： 放主题对应目录也可以，参考主题配置文件注释中的说明。 添加显示当前进度配置: 在 主题 的_config.yml中查找scrollpercent并将参数改为true即可。 配置首页只显示简介默认情况首页显示的是文章全文，为了查看方便可以为首页配置预览，ThanksTo这篇文章。修改主题配置文件：123auto_excerpt: enable: true length: 150但是默认会把数据格式成无格式的字符串，很是丑陋。配置文件上其实说明了，需要在文章中用下面的注释分割你想要显示的部分。12345希望在首页看到的部分..&lt;!-- more --&gt;不希望在首页看到的部分.. 添加资源目录资源文件主要用来存放例如图片、CSS、JS等文件。如果数量不多，可以放在source/images文件夹中，通过![](/images/image.jpg)引用它们。但是这样资源文件时间一长还是会比较难管理，所以需要开启“文章资源文件夹”功能。修改站点配置：12# _config.ymlpost_asset_folder: true开启后，通过hexo new创建文章时，会自动创建一个同名目录用于存放资源文件。但是使用markdown语法直接引用站点首页无法显示的，所以需要使用下面的语法。1234&#123;% asset_path xxx %&#125;&#123;% asset_img xxx [title] %&#125;&lt;!-- 用于引用js --&gt;&#123;% asset_link xxx [title] %&#125;具体可参考官方：资源文件夹。 压缩静态资源由于hexo在生成静态文件时会产生很多空行，使用chenzhutian/hexo-all-minifier插件来压缩这些文件。安装：1npm install hexo-all-minifier --save对于mac用户还需要安装下面的依赖：1brew install libtool automake autoconf nasm配置站点配置文件：1all_minifier: true并且该插件还支持配置需要压缩的其他内容，可以在官方文档中查看。 压缩静态资源-使用gulp偶遇一大佬使用这个办法进行压缩，感觉很给力的样子。由于我没有试过，这里分享一下链接：Tips for Hexo configuration。 部署到GitHub保能够正常push项目后，按照下面方法进行部署。修改站点配置文件：12345678deploy: type: git repo: https://github.com/billxllid/billxllid.github.io.git branch: master message: Update name: billxllid email: zangjiaao@yahoo.com ignore_hidden: true生成静态文件： 建议先hexo clean清理一下旧数据。12hexo cleanhexo generate📖 说明： 有时候修改文件名、删除分类或者标签，页面上的计数、列表会异常（计数加1，分类没有删除改名之前的文章标题），这时候使用clean就能解决了。部署到Github：1hexo deploy过一会就能够访问了（github需要一段时间处理）。如果有自己域名的同学，可以将域名加一条CNAME到你得gitio上面，然后在项目设置里配置一下。 让文章依据updatedp排序安利博主,我参考这篇文章Hexo文章按照更新时间排序·LevelUp.其实只需要为模板scaffolds/post.md中添加配置头部即可,类似如下:12345678910---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;# 要插入updated时间, VSCode中安装`Insert Date String`# OS X 按 ⇧ + ⌘ + I，Windows 和 Linux 按 Ctrl + Shift + Iupdated:categories: ""tags: ----随后,需要修改主配置文件_comfig.yml中排序方式1234index_generator: path: '' per_page: 10 order_by: -updated # 默认-date每次更新文章需要手动添加updated时间,如果你用VSCode就没这么麻烦了.只需要安装Insert Date String即可.Mac OS X 按 ⇧ + ⌘ + I，Windows 和 Linux 按 Ctrl + Shift + I快捷键插入很爽. 支持checkbox更新于: 2018-08-22 02:40:23由于使用了hexo-renderer-markdown-it-plus插件导致不识别task_list语法, 导致写TODO的时候不太舒服, 其实这个插件自己支持安装markdown-it插件的, 官方下面有说明语法格式.安装: markdown-it-task-checkbox1npm install markdown-it-task-checkbox --save使能: 修改hexo的_config.yml配置123456789101112131415markdown_it_plus: highlight: true html: true xhtmlOut: true breaks: true langPrefix: linkify: true typographer: quotes: “”‘’ pre_class: highlight # 新增下面内容 plugins: - plugin: name: markdown-it-task-checkbox enable: true 功能拓展 （推荐）markdown-it-plus 插件这个插件支持TOC和emoji特性，而且不需要为了追求与Next的兼容性去修改配置。同时还兼容sub、sup也就是角标、Katex公式、ins下划线和删除线渲染，可见强大，因此推荐。了解更多。安装: 在站点目录hexo_blog执行12npm un hexo-renderer-marked --savenpm i hexo-renderer-markdown-it-plus --save配置: 修改 站点 的config.yml文件12345678910markdown_it_plus: highlight: true html: true xhtmlOut: true breaks: true langPrefix: linkify: true typographer: quotes: “”‘’ pre_class: highlight （不推荐）emoji支持切换渲染: 因为hexo-renderer-marked不支持（实际是支持的crimx/hexo-filter-github-emojis太丑了），固改用markdown-it渲染12npm un hexo-renderer-marked --savenpm i hexo-renderer-markdown-it --save安装:1npm install markdown-it-emoji --save配置: 注意这里修改的是 站点 的_config.yml123456789101112131415161718192021markdown: render: html: true xhtmlOut: false breaks: true linkify: true typographer: true quotes: &apos;“”‘’&apos; plugins: - markdown-it-abbr - markdown-it-footnote - markdown-it-ins - markdown-it-sub - markdown-it-sup - markdown-it-emoji #用emoji插件 anchors: level: 1 collisionSuffix: &apos;v&apos; permalink: true permalinkClass: header-anchor permalinkSymbol: &apos;&apos; #设置&apos;¶&apos;会导致页面中显示出错更多详见 Hexo添加emoji | Very9s 。 （不推荐）hexo-TOC插件bubkoo/hexo-toc与Next主题有极大的冲突，安装之后将导致**侧边目录失效！！**不推荐安装。若迫不得已需要安装也可依据下面内容调整。弥补方法: 通过将${blog_root}/node_modules/hexo-toc/lib/filter.js中的28行~31行改为下面内容。1234$title.attr(&apos;id&apos;, id);// $title.children(&apos;a&apos;).remove();// $title.html( &apos;&lt;span id=&quot;&apos; + id + &apos;&quot;&gt;&apos; + $title.html() + &apos;&lt;/span&gt;&apos; );// $title.removeAttr(&apos;id&apos;);随后还需要替换’markdown-it’，请见上一章节相关安装方法，并修改hexo-toc的配置为：123456789toc: maxdepth: 3 class: toc slugify: transliteration decodeEntities: false anchor: position: after symbol: &apos;&apos; #主要删除了symbol style: header-anchor更多详见 Content's link show 'undefine' · Issue #11 · YenYuHsuan/hexo-theme-beantech 中@fawks96的回答。 emoji速查表😂Emoji cheat sheet for GitHub, Basecamp and other services 404页面直接创建source/404.html文件即可，我直接把谷歌文字的错误页面拔了下来改了改，感觉挺有“windows”错误页面的风格，页面源码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091ayout: falsetitle: "404"---&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt; &lt;meta content="text/html; charset=utf-8" http-equiv="Content-Type"&gt; &lt;title&gt;Oops!&lt;/title&gt; &lt;style type="text/css"&gt; * &#123; padding: 0; margin: 0; &#125; html &#123; overflow-y: scroll; &#125; body &#123; background: #fff; font-family: '微软雅黑'; color: #333; font-size: 16px; &#125; img &#123; border: 0; &#125; .error &#123; padding: 24px 48px; &#125; .face &#123; font-size: 100px; font-weight: normal; line-height: 120px; margin-bottom: 12px; &#125; h1 &#123; font-size: 32px; line-height: 48px; &#125; .error .content &#123; padding-top: 10px &#125; .error .info &#123; margin-bottom: 12px; &#125; .error .info .title &#123; margin-bottom: 3px; &#125; .error .info .title h3 &#123; color: #000; font-weight: 700; font-size: 16px; &#125; .error .info .text &#123; line-height: 24px; &#125; .copyright &#123; padding: 12px 48px; color: #999; &#125; .copyright a &#123; color: #000; text-decoration: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="error"&gt; &lt;p class="face"&gt;:(&lt;/p&gt; &lt;h1&gt;找不到指定文件...&lt;/h1&gt; &lt;div class="title"&gt; &lt;h3&gt;&amp;nbsp;&lt;/h3&gt; &lt;/div&gt; &lt;div class="text"&gt; &lt;p&gt;错误代码：404. &lt;/p&gt; &lt;/div&gt; 搜索（本地）安装: 站点根目录下执行1npm install hexo-generator-searchdb --save配置1: 站点_config.yml中修改12345search: path: search.xml field: post format: html limit: 10000配置2: 主题_config.yml中修改123456789# Local search# Dependencies: https://github.com/flashlab/hexo-generator-searchlocal_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 搜索（algolia）本地解析server.xml出现问题，导致本地搜索功能失效，没办法只好采用线上搜索模式。配置方法可参考theme-next/hexo-theme-next。注册algolia账号：访问Algolia官网注册一个账号。获取ID：其中Application ID和Search-only API key需要在下图中获取。indexName需要自己设置：然后站点配置文件需要以下参数：12345algolia: applicationID: 'Application ID' apiKey: 'Search-only API key' indexName: 'indexName' chunkSize: 5000生成数据：对，没错，手动生成…不过晚了可以写个脚本之类的，其实无非就是每次需要执行两条命令而已。1234# 其中的API Key就是上面的export HEXO_ALGOLIA_INDEXING_KEY=Search-Only API keyhexo cleanhexo algolia安装next插件：12cd themes/nextgit clone https://github.com/theme-next/theme-next-algolia-instant-search source/lib/algolia-instant-search配置CDN: 编辑主题的配置文件。1234567vendors: ... # Internal version: 1 # https://www.algolia.com algolia_instant_js: https://cdn.jsdelivr.net/npm/instantsearch.js@2.4.1/dist/instantsearch.js algolia_instant_css: https://cdn.jsdelivr.net/npm/instantsearch.js@2.4.1/dist/instantsearch.min.css ...打开功能： 最后一步是在主题配置文件中开启。123456789# Algolia Searchalgolia_search: enable: true hits: per_page: 10 labels: input_placeholder: Search for Posts hits_empty: "We didn't find any results for the search: $&#123;query&#125;" hits_stats: "$&#123;hits&#125; results found in $&#123;time&#125; ms" 创建文章时自动打开VSCode请参考该文章new 时自动打开 VSCode。 添加评论功能经过测试，多说，来必达都不够友好，发现其他博客上使用“gitment”以及“Hypercomments”作为评论解决方案，试了以下非常给力。官网在这里，登录使用谷歌，所以自备梯子。注册，并获取获取ID注册这里就不细说了，获取ID需要到：settiong - Widget - code的widget_id值。编辑主题配置文件12# Hypercommentshypercomments_id: xxxxxx还有另一种方式，不过没有用过，但是好多人都在用：Valine，以后可以对比一下。 添加页面载入进度条Next主题原生支持，修改主题配置开启即可。123456789101112131415161718pace: true# Themes list:#pace-theme-big-counter#pace-theme-bounce#pace-theme-barber-shop#pace-theme-center-atom#pace-theme-center-circle#pace-theme-center-radar#pace-theme-center-simple#pace-theme-corner-indicator#pace-theme-fill-left#pace-theme-flash#pace-theme-loading-bar#pace-theme-mac-osx#pace-theme-minimal# For example# pace_theme: pace-theme-center-simplepace_theme: pace-theme-flash更详细说明可参考：theme-next/theme-next-pace。 其他功能插入音乐Hexo+Next主题优化。APlayerHexo博客中插入音乐 声明版权： 2018-now，🇨🇳，zangjiaao&lt;zangjiaao@yahoo.com&gt;由家浩创作并维护的zangjiaao's blog博客所有文章除特别声明外，均采用&quot;署名-非商业性使用-相同方式共享4.0(CC BY-NC-SA 4.0)国际许可证&quot;。本文首发于zangjiaao’s blog博客，转载请注明出处。]]></content>
      <categories>
        <category>02_环境搭建</category>
      </categories>
  </entry>
</search>
